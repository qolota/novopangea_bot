{"ast":null,"code":"const _ = require('lodash');\nconst fetchAccountAssetsWaxData = require('../atomicassets/api/fetchAccountAssetsWaxData');\nconst fetchVehicleToMark = require('./api/fetchVehicleToMark');\nconst fetchTodayDeathRally = require('./api/fetchTodayDeathRally');\nconst fetchAccountTokens = require('./api/fetchAccountTokens');\nconst isDeathRallyPreparationTime = require('./utils/isDeathRallyPreparationTime');\nconst fetchAssets = require('../atomicassets/api/fetchAssets');\nconst joinDeathRally = require('./actions/joinDeathRally');\nconst fetchTomorrowDeathRally = require('./api/fetchTomorrowDeathRally');\nconst ACCOUNT_CAPABILITIES = require('../configs/ACCOUNT_CAPABILITIES');\nconst QUALITY = require('./consts/QUALITY');\nconst RARITY = require('./consts/RARITY');\nconst GAME_VALUES = require('./consts/GAME_VALUES');\nconst getTeamKey = ({\n  vehicle,\n  drivers\n}) => {\n  const vehicleKey = `${vehicle.mark}|${vehicle.rarity}|${vehicle.quality}`;\n  const driversKey = _(drivers).sortBy(driver => driver.name).map(driver => `${driver.name}|${driver.rarity}|${driver.quality}`).value().join('|');\n  return `${vehicleKey}|${driversKey}`;\n};\nconst joinTodayDeathRallyCalcNextAction = async ({\n  accountName\n}) => {\n  // return {\n  //     action: 'wait',\n  //     message: 'Not implemented yet',\n  // };\n\n  // TODO: uncomment when the script is ready\n  // if (!isDeathRallyPreparationTime()) {\n  //     return {\n  //         action: 'wait',\n  //         message: 'Not a death rally preparation time',\n  //     };\n  // }\n\n  const allowedCombinations = ACCOUNT_CAPABILITIES[accountName].novarally_death_rally_combinations || [];\n  const todayDeathRallyTeams = await fetchTodayDeathRally();\n  const tomorrowDeathRallyTeams = await fetchTomorrowDeathRally();\n  const isTodayDeathRallyEnded = _(todayDeathRallyTeams).find(deathRally => deathRally.time > 0) != null;\n  const deathRallyTeams = isTodayDeathRallyEnded ? tomorrowDeathRallyTeams : todayDeathRallyTeams;\n  const vehicleToMark = await fetchVehicleToMark();\n  const accountTokens = await fetchAccountTokens({\n    accountName\n  });\n  const {\n    drivers,\n    vehicles\n  } = await fetchAccountAssetsWaxData({\n    accountName,\n    assetParams: [{\n      key: 'drivers',\n      params: {\n        collectionName: 'novarallywax',\n        schemaName: 'drivers'\n      },\n      customProcessor: ({\n        asset\n      }) => ({\n        rarity: asset.params.Rarity,\n        quality: asset.params.Quality,\n        promotionPoints: asset.params[\"Promotion Points\"] == null ? 0 : Number(asset.params[\"Promotion Points\"]),\n        isAvailableForDR: asset.params['Available for Death Rally'] === '1' ? true : false\n      })\n    }, {\n      key: 'vehicles',\n      params: {\n        collectionName: 'novarallywax',\n        schemaName: 'vehicles'\n      },\n      customProcessor: ({\n        asset\n      }) => ({\n        rarity: asset.params.Rarity,\n        quality: asset.params.Quality,\n        mark: vehicleToMark[asset.params.name],\n        promotionPoints: asset.params[\"Promotion Points\"] == null ? 0 : Number(asset.params[\"Promotion Points\"]),\n        freeRacesCounter: asset.params['Free Races Counter'] == null ? 0 : Number(asset.params['Free Races Counter']),\n        lastFreeRaceDate: asset.params['Last Free Race Date'] == null ? 0 : Number(asset.params['Last Free Race Date']),\n        isDamaged: asset.params['Damaged'] === '1' ? true : false,\n        isAvailableForDR: asset.params['Available for Death Rally'] === '1' ? true : false\n      })\n    }]\n  });\n  let allowedDrivers = _(drivers).filter(driver => driver.isAvailableForDR).filter(driver => driver.rarity === RARITY.COMMON).filter(driver => driver.quality === QUALITY.ROOKIE).filter(driver => driver.mintId !== 1).sortBy(driver => driver.promotionPoints).value();\n  let allowedVehicles = _(vehicles).filter(vehicle => vehicle.isAvailableForDR).filter(vehicle => !vehicle.isDamaged).filter(vehicle => vehicle.rarity === RARITY.CLASSIC || vehicle.rarity === RARITY.RARE).filter(vehicle => vehicle.quality === QUALITY.ROOKIE).sortBy(driver => driver.promotionPoints).value();\n  let ownDeathRallyTeams = _(deathRallyTeams).filter(team => team.accountName === accountName).value();\n  let ownDeathRallyAssets = [];\n  if (ownDeathRallyTeams.length > 0) {\n    ownDeathRallyAssets = _(await fetchAssets({\n      params: {\n        ids: _(ownDeathRallyTeams).map(team => [...team.driverIds, team.vehicleId]).flatten().value().join(',')\n      },\n      customProcessor: ({\n        asset\n      }) => {\n        const _asset = {\n          assetId: asset.asset_id,\n          rarity: asset.data.Rarity,\n          quality: asset.data.Quality\n        };\n        switch (asset.schema.schema_name) {\n          case 'drivers':\n            return _asset;\n          case 'vehicles':\n            return {\n              ..._asset,\n              mark: vehicleToMark[asset.data.name]\n            };\n        }\n      }\n    })).value();\n    ownDeathRallyTeams = _(ownDeathRallyTeams).map(team => ({\n      ..._.omit(team, ['driverIds', 'vehicleId']),\n      drivers: _(team.driverIds).map(driverId => _(ownDeathRallyAssets).find(asset => asset.assetId === driverId)).value(),\n      vehicle: _(ownDeathRallyAssets).find(asset => asset.assetId === team.vehicleId)\n    })).value();\n  }\n  const notUsedCombinations = _(allowedCombinations).filter(combination => {\n    const cKey = getTeamKey({\n      vehicle: combination.vehicle,\n      drivers: combination.drivers\n    });\n    return _(ownDeathRallyTeams).filter(team => {\n      const tKey = getTeamKey({\n        vehicle: team.vehicle,\n        drivers: team.drivers\n      });\n      return tKey === cKey;\n    }).value().length === 0;\n  }).value();\n  if (notUsedCombinations.length === 0) {\n    return {\n      action: 'wait',\n      message: 'No available combinations'\n    };\n  }\n  const combinations = _(notUsedCombinations).map(combination => {\n    const vehicle = _(allowedVehicles).find(allowedVehicle => {\n      return combination.vehicle.mark === allowedVehicle.mark && combination.vehicle.quality === allowedVehicle.quality && combination.vehicle.rarity === allowedVehicle.rarity;\n    });\n    if (vehicle == null) {\n      return null;\n    }\n    const drivers = _(combination.drivers).map(driver => {\n      return _(allowedDrivers).find(allowedDriver => {\n        return driver.name === allowedDriver.name && driver.quality === allowedDriver.quality && driver.rarity === allowedDriver.rarity;\n      });\n    }).compact().value();\n    if (drivers.length < 2) {\n      return null;\n    }\n\n    // filter out used assets\n    allowedVehicles = _(allowedVehicles).filter(allowedVehicle => allowedVehicle.id !== vehicle.id).value();\n    allowedDrivers = _(allowedDrivers).filter(allowedDriver => drivers.find(driver => allowedDriver.id === driver.id) == null).value();\n    return {\n      vehicle,\n      drivers,\n      combination\n    };\n  }).compact().value();\n  if (combinations.length === 0) {\n    return {\n      action: 'wait',\n      message: `No available drivers/vehicles but ${notUsedCombinations.length} available combinations`\n    };\n  }\n  const tokenAmount = _(accountTokens).find(token => token.tokenName === GAME_VALUES.DEATH_RALLY_PRICE.symbol).amount;\n  if (GAME_VALUES.DEATH_RALLY_PRICE.value * combinations.length > tokenAmount) {\n    return {\n      action: 'wait',\n      message: `Not enough ${GAME_VALUES.DEATH_RALLY_PRICE.symbol}`\n    };\n  }\n  return {\n    action: 'join_death_rally',\n    actions: _(combinations).map(combination => {\n      return joinDeathRally({\n        accountName,\n        vehicleId: combination.vehicle.id,\n        driverIds: _(combination.drivers).map(driver => driver.id).value()\n      });\n    }).flatten().value()\n  };\n\n  // console.log(allowedVehicles, allowedCombinations, allowedDrivers, accountTokens, ownDeathRallyTeams, ownDeathRallyAssets, notUsedCombinations);\n  // console.log(combinations);\n};\n\nmodule.exports = joinTodayDeathRallyCalcNextAction;","map":{"version":3,"names":["_","require","fetchAccountAssetsWaxData","fetchVehicleToMark","fetchTodayDeathRally","fetchAccountTokens","isDeathRallyPreparationTime","fetchAssets","joinDeathRally","fetchTomorrowDeathRally","ACCOUNT_CAPABILITIES","QUALITY","RARITY","GAME_VALUES","getTeamKey","vehicle","drivers","vehicleKey","mark","rarity","quality","driversKey","sortBy","driver","name","map","value","join","joinTodayDeathRallyCalcNextAction","accountName","allowedCombinations","novarally_death_rally_combinations","todayDeathRallyTeams","tomorrowDeathRallyTeams","isTodayDeathRallyEnded","find","deathRally","time","deathRallyTeams","vehicleToMark","accountTokens","vehicles","assetParams","key","params","collectionName","schemaName","customProcessor","asset","Rarity","Quality","promotionPoints","Number","isAvailableForDR","freeRacesCounter","lastFreeRaceDate","isDamaged","allowedDrivers","filter","COMMON","ROOKIE","mintId","allowedVehicles","CLASSIC","RARE","ownDeathRallyTeams","team","ownDeathRallyAssets","length","ids","driverIds","vehicleId","flatten","_asset","assetId","asset_id","data","schema","schema_name","omit","driverId","notUsedCombinations","combination","cKey","tKey","action","message","combinations","allowedVehicle","allowedDriver","compact","id","tokenAmount","token","tokenName","DEATH_RALLY_PRICE","symbol","amount","actions","module","exports"],"sources":["/Users/germangurov/projects/wax_bot/src/novarallywax/joinTodayDeathRallyCalcNextAction.js"],"sourcesContent":["const _ = require('lodash');\nconst fetchAccountAssetsWaxData = require('../atomicassets/api/fetchAccountAssetsWaxData');\nconst fetchVehicleToMark = require('./api/fetchVehicleToMark');\nconst fetchTodayDeathRally = require('./api/fetchTodayDeathRally');\nconst fetchAccountTokens = require('./api/fetchAccountTokens');\nconst isDeathRallyPreparationTime = require('./utils/isDeathRallyPreparationTime');\nconst fetchAssets = require('../atomicassets/api/fetchAssets');\nconst joinDeathRally = require('./actions/joinDeathRally');\nconst fetchTomorrowDeathRally = require('./api/fetchTomorrowDeathRally');\nconst ACCOUNT_CAPABILITIES = require('../configs/ACCOUNT_CAPABILITIES');\nconst QUALITY = require('./consts/QUALITY');\nconst RARITY = require('./consts/RARITY');\nconst GAME_VALUES = require('./consts/GAME_VALUES');\n\nconst getTeamKey = ({\n    vehicle,\n    drivers,\n}) => {\n    const vehicleKey = `${vehicle.mark}|${vehicle.rarity}|${vehicle.quality}`;\n    const driversKey = _(drivers)\n        .sortBy(driver => driver.name)\n        .map(driver => `${driver.name}|${driver.rarity}|${driver.quality}`)\n        .value()\n        .join('|');\n\n    return `${vehicleKey}|${driversKey}`;\n};\n\nconst joinTodayDeathRallyCalcNextAction = async ({\n    accountName,\n}) => {\n    // return {\n    //     action: 'wait',\n    //     message: 'Not implemented yet',\n    // };\n\n    // TODO: uncomment when the script is ready\n    // if (!isDeathRallyPreparationTime()) {\n    //     return {\n    //         action: 'wait',\n    //         message: 'Not a death rally preparation time',\n    //     };\n    // }\n\n    const allowedCombinations = ACCOUNT_CAPABILITIES[accountName].novarally_death_rally_combinations || [];\n    const todayDeathRallyTeams = await fetchTodayDeathRally();\n    const tomorrowDeathRallyTeams = await fetchTomorrowDeathRally();\n    const isTodayDeathRallyEnded = _(todayDeathRallyTeams)\n        .find(deathRally => deathRally.time > 0) != null;\n    const deathRallyTeams = isTodayDeathRallyEnded\n        ? tomorrowDeathRallyTeams\n        : todayDeathRallyTeams;\n\n    const vehicleToMark = await fetchVehicleToMark();\n    const accountTokens = await fetchAccountTokens({accountName});\n    const {\n        drivers,\n        vehicles,\n    } = await fetchAccountAssetsWaxData({\n        accountName,\n        assetParams: [\n            {\n                key: 'drivers',\n                params: {\n                    collectionName: 'novarallywax',\n                    schemaName: 'drivers',\n                },\n                customProcessor: ({asset}) => ({\n                    rarity: asset.params.Rarity,\n                    quality: asset.params.Quality,\n                    promotionPoints: asset.params[\"Promotion Points\"] == null\n                        ? 0\n                        : Number(asset.params[\"Promotion Points\"]),\n                    isAvailableForDR: asset.params['Available for Death Rally'] === '1'\n                        ? true\n                        : false,\n                }),\n            },\n            {\n                key: 'vehicles',\n                params: {\n                    collectionName: 'novarallywax',\n                    schemaName: 'vehicles',\n                },\n                customProcessor: ({asset}) => ({\n                    rarity: asset.params.Rarity,\n                    quality: asset.params.Quality,\n                    mark: vehicleToMark[asset.params.name],\n                    promotionPoints: asset.params[\"Promotion Points\"] == null\n                        ? 0\n                        : Number(asset.params[\"Promotion Points\"]),\n                    freeRacesCounter: asset.params['Free Races Counter'] == null\n                        ? 0\n                        : Number(asset.params['Free Races Counter']),\n                    lastFreeRaceDate: asset.params['Last Free Race Date'] == null\n                        ? 0\n                        : Number(asset.params['Last Free Race Date']),\n                    isDamaged: asset.params['Damaged'] === '1'\n                        ? true\n                        : false,\n                    isAvailableForDR: asset.params['Available for Death Rally'] === '1'\n                        ? true\n                        : false,\n                }),\n            },\n        ],\n    });\n    let allowedDrivers = _(drivers)\n        .filter(driver => driver.isAvailableForDR)\n        .filter(driver => driver.rarity === RARITY.COMMON)\n        .filter(driver => driver.quality === QUALITY.ROOKIE)\n        .filter(driver => driver.mintId !== 1)\n        .sortBy(driver => driver.promotionPoints)\n        .value();\n    let allowedVehicles = _(vehicles)\n        .filter(vehicle => vehicle.isAvailableForDR)\n        .filter(vehicle => !vehicle.isDamaged)\n        .filter(vehicle => vehicle.rarity === RARITY.CLASSIC || vehicle.rarity === RARITY.RARE)\n        .filter(vehicle => vehicle.quality === QUALITY.ROOKIE)\n        .sortBy(driver => driver.promotionPoints)\n        .value();\n    let ownDeathRallyTeams = _(deathRallyTeams)\n        .filter(team => team.accountName === accountName)\n        .value();\n    let ownDeathRallyAssets = [];\n    \n    if (ownDeathRallyTeams.length > 0) {\n        ownDeathRallyAssets = _(await fetchAssets({\n            params: {\n                ids: _(ownDeathRallyTeams)\n                .map(team => ([\n                    ...team.driverIds,\n                    team.vehicleId,\n                ]))\n                .flatten()\n                .value()\n                .join(','),\n            },\n            customProcessor: ({asset}) => {\n                const _asset = {\n                    assetId: asset.asset_id,\n                    rarity: asset.data.Rarity,\n                    quality: asset.data.Quality,\n                };\n    \n                switch (asset.schema.schema_name) {\n                    case 'drivers':\n                        return _asset;\n                    case 'vehicles':\n                        return {\n                            ..._asset,\n                            mark: vehicleToMark[asset.data.name],\n                        };\n                }\n            },\n        }))\n            .value();\n        \n        ownDeathRallyTeams = _(ownDeathRallyTeams)\n            .map(team => ({\n                ..._.omit(team, ['driverIds', 'vehicleId']),\n                drivers: _(team.driverIds)\n                    .map(driverId => _(ownDeathRallyAssets)\n                        .find(asset => asset.assetId === driverId))\n                    .value(),\n                vehicle: _(ownDeathRallyAssets)\n                    .find(asset => asset.assetId === team.vehicleId),\n            }))\n            .value();\n    }\n    \n    const notUsedCombinations = _(allowedCombinations)\n        .filter(combination => {\n            const cKey = getTeamKey({\n                vehicle: combination.vehicle,\n                drivers: combination.drivers,\n            });\n\n            return _(ownDeathRallyTeams)\n                .filter(team => {\n                    const tKey = getTeamKey({\n                        vehicle: team.vehicle,\n                        drivers: team.drivers,\n                    });\n\n                    return tKey === cKey;\n                })\n                .value().length === 0;\n        })\n        .value();\n    \n    if (notUsedCombinations.length === 0) {\n        return {\n            action: 'wait',\n            message: 'No available combinations',\n        };\n    }\n\n    const combinations = _(notUsedCombinations)\n        .map(combination => {\n            const vehicle = _(allowedVehicles)\n                .find(allowedVehicle => {\n                    return combination.vehicle.mark === allowedVehicle.mark\n                        && combination.vehicle.quality === allowedVehicle.quality\n                        && combination.vehicle.rarity === allowedVehicle.rarity; \n                });\n            \n            if (vehicle == null) {\n                return null;\n            }\n            const drivers = _(combination.drivers)\n                .map(driver => {\n                    return _(allowedDrivers)\n                        .find(allowedDriver => {\n                            return driver.name === allowedDriver.name\n                                && driver.quality === allowedDriver.quality\n                                && driver.rarity === allowedDriver.rarity; \n                        });\n                })\n                .compact()\n                .value();\n            \n            if (drivers.length < 2) {\n                return null;\n            }\n\n            // filter out used assets\n            allowedVehicles = _(allowedVehicles)\n                .filter(allowedVehicle => allowedVehicle.id !== vehicle.id)\n                .value();\n            allowedDrivers = _(allowedDrivers)\n                .filter(allowedDriver => drivers.find(driver => allowedDriver.id === driver.id) == null)\n                .value();\n\n            return {\n                vehicle,\n                drivers,\n                combination,\n            };\n        })\n        .compact()\n        .value();\n\n    if (combinations.length === 0) {\n        return {\n            action: 'wait',\n            message: `No available drivers/vehicles but ${notUsedCombinations.length} available combinations`,\n        };\n    }\n\n    const tokenAmount = _(accountTokens)\n        .find(token => token.tokenName === GAME_VALUES.DEATH_RALLY_PRICE.symbol)\n        .amount;\n    if (GAME_VALUES.DEATH_RALLY_PRICE.value * combinations.length > tokenAmount) {\n        return {\n            action: 'wait',\n            message: `Not enough ${GAME_VALUES.DEATH_RALLY_PRICE.symbol}`,\n        };\n    }\n    \n    return {\n        action: 'join_death_rally',\n        actions: _(combinations)\n            .map(combination => {\n                return joinDeathRally({\n                    accountName,\n                    vehicleId: combination.vehicle.id,\n                    driverIds: _(combination.drivers)\n                        .map(driver => driver.id)\n                        .value(),\n                })\n            })\n            .flatten()\n            .value(),\n    };\n    \n\n    // console.log(allowedVehicles, allowedCombinations, allowedDrivers, accountTokens, ownDeathRallyTeams, ownDeathRallyAssets, notUsedCombinations);\n    // console.log(combinations);\n};\n\nmodule.exports = joinTodayDeathRallyCalcNextAction;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}