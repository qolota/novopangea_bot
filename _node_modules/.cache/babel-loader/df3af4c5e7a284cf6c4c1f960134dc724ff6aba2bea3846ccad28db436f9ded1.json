{"ast":null,"code":"/**\n * pure javascript functions to read and write 32-bit and 64-bit IEEE 754 floating-point\n *\n * Copyright (C) 2017-2019 Andras Radics\n * Licensed under the Apache License, Version 2.0\n */\n// removed buffer\n\n'use strict';\n\nvar isBigeCpu = false;\nvar readFloat32Array, writeFloat32Array, readFloat32ArrayRev, writeFloat32ArrayRev;\nvar readFloat64Array, writeFloat64Array, readFloat64ArrayRev, writeFloat64ArrayRev;\n\n// test FloatArray existence with && to not throw off code coverage\ntypeof Float32Array === 'function' && function () {\n  var _fp32 = new Float32Array(1);\n  var _b32 = new Uint8Array(_fp32.buffer);\n  _fp32[0] = -1;\n  isBigeCpu = _b32[3] === 0;\n  readFloat32Array = function readFloat32Array(buf, pos) {\n    pos = pos || 0;\n    if (pos < 0 || pos + 4 > buf.length) return 0;\n    _b32[0] = buf[pos++];\n    _b32[1] = buf[pos++];\n    _b32[2] = buf[pos++];\n    _b32[3] = buf[pos];\n    //_b32[0] = buf[pos+0]; _b32[1] = buf[pos+1]; _b32[2] = buf[pos+2]; _b32[3] = buf[pos+3];\n    return _fp32[0];\n  };\n  readFloat32ArrayRev = function readFloat32ArrayRev(buf, pos) {\n    pos = pos || 0;\n    if (pos < 0 || pos + 4 > buf.length) return 0;\n    _b32[3] = buf[pos++];\n    _b32[2] = buf[pos++];\n    _b32[1] = buf[pos++];\n    _b32[0] = buf[pos];\n    //_b32[3] = buf[pos+0]; _b32[2] = buf[pos+1]; _b32[1] = buf[pos+2]; _b32[0] = buf[pos+3];\n    return _fp32[0];\n  };\n  writeFloat32Array = function writeFloat32Array(buf, v, pos) {\n    pos = pos || 0;\n    _fp32[0] = v;\n    buf[pos++] = _b32[0];\n    buf[pos++] = _b32[1];\n    buf[pos++] = _b32[2];\n    buf[pos] = _b32[3];\n    //buf[pos+0] = _b32[0]; buf[pos+1] = _b32[1]; buf[pos+2] = _b32[2]; buf[pos+3] = _b32[3];\n  };\n\n  writeFloat32ArrayRev = function writeFloat32ArrayRev(buf, v, pos) {\n    pos = pos || 0;\n    _fp32[0] = v;\n    buf[pos++] = _b32[3];\n    buf[pos++] = _b32[2];\n    buf[pos++] = _b32[1];\n    buf[pos] = _b32[0];\n    //buf[pos+0] = _b32[3]; buf[pos+1] = _b32[2]; buf[pos+2] = _b32[1]; buf[pos+3] = _b32[0];\n  };\n}();\n\ntypeof Float64Array === 'function' && function () {\n  var _fp64 = new Float64Array(1);\n  var _b64 = new Uint8Array(_fp64.buffer);\n  readFloat64Array = function readFloat64Array(buf, pos) {\n    pos = pos || 0;\n    if (pos < 0 || pos + 8 > buf.length) return 0;\n    //_b64[0] = buf[pos++]; _b64[1] = buf[pos++]; _b64[2] = buf[pos++]; _b64[3] = buf[pos++];\n    //_b64[4] = buf[pos++]; _b64[5] = buf[pos++]; _b64[6] = buf[pos++]; _b64[7] = buf[pos];\n    _b64[0] = buf[pos + 0];\n    _b64[1] = buf[pos + 1];\n    _b64[2] = buf[pos + 2];\n    _b64[3] = buf[pos + 3];\n    _b64[4] = buf[pos + 4];\n    _b64[5] = buf[pos + 5];\n    _b64[6] = buf[pos + 6];\n    _b64[7] = buf[pos + 7];\n    return _fp64[0];\n  };\n  readFloat64ArrayRev = function readFloat64ArrayRev(buf, pos) {\n    pos = pos || 0;\n    if (pos < 0 || pos + 8 > buf.length) return 0;\n    //_b64[7] = buf[pos++]; _b64[6] = buf[pos++]; _b64[5] = buf[pos++]; _b64[4] = buf[pos++];\n    //_b64[3] = buf[pos++]; _b64[2] = buf[pos++]; _b64[1] = buf[pos++]; _b64[0] = buf[pos];\n    _b64[7] = buf[pos + 0];\n    _b64[6] = buf[pos + 1];\n    _b64[5] = buf[pos + 2];\n    _b64[4] = buf[pos + 3];\n    _b64[3] = buf[pos + 4];\n    _b64[2] = buf[pos + 5];\n    _b64[1] = buf[pos + 6];\n    _b64[0] = buf[pos + 7];\n    return _fp64[0];\n  };\n  writeFloat64Array = function writeFloat64Array(buf, v, pos) {\n    pos = pos || 0;\n    _fp64[0] = v;\n    buf[pos + 0] = _b64[0];\n    buf[pos + 1] = _b64[1];\n    buf[pos + 2] = _b64[2];\n    buf[pos + 3] = _b64[3];\n    buf[pos + 4] = _b64[4];\n    buf[pos + 5] = _b64[5];\n    buf[pos + 6] = _b64[6];\n    buf[pos + 7] = _b64[7];\n  };\n  writeFloat64ArrayRev = function writeFloat64ArrayRev(buf, v, pos) {\n    pos = pos || 0;\n    _fp64[0] = v;\n    buf[pos + 0] = _b64[7];\n    buf[pos + 1] = _b64[6];\n    buf[pos + 2] = _b64[5];\n    buf[pos + 3] = _b64[4];\n    buf[pos + 4] = _b64[3];\n    buf[pos + 5] = _b64[2];\n    buf[pos + 6] = _b64[1];\n    buf[pos + 7] = _b64[0];\n  };\n}();\n\n// arithmetic operations preserve NaN, but logical ops (, >>, etc) convert them to zero\n// Assemble the word to generate NaN if any reads are undefined (outside the bounds of the array).\nfunction readWord(buf, offs, dirn) {\n  var a = buf[offs++],\n    b = buf[offs++],\n    c = buf[offs++],\n    d = buf[offs];\n  return dirn === 'bige' ? ((a * 256 + b) * 256 + c) * 256 + d : ((d * 256 + c) * 256 + b) * 256 + a;\n}\nfunction writeWord(buf, v, offs, dirn) {\n  var a = v >>> 24 & 0xff,\n    b = v >> 16 & 0xff,\n    c = v >> 8 & 0xff,\n    d = v & 0xff;\n  dirn === 'bige' ? (buf[offs++] = a, buf[offs++] = b, buf[offs++] = c, buf[offs] = d) : (buf[offs++] = d, buf[offs++] = c, buf[offs++] = b, buf[offs] = a);\n}\n\n// write the two-word value [hi,lo] where hi holds the 32 msb bits and lo the 32 lsb bits\nfunction writeDoubleWord(buf, hi, lo, offs, dirn) {\n  if (dirn === 'bige') {\n    writeWord(buf, hi, offs, dirn);\n    writeWord(buf, lo, offs + 4, dirn);\n  } else {\n    writeWord(buf, lo, offs, dirn);\n    writeWord(buf, hi, offs + 4, dirn);\n  }\n}\n\n// given an exponent n, return 2**n\n// n is always an integer, faster to shift when possible\n// Note that nodejs Math.pow() is faster than a lookup table (may be caching)\nvar _2eXp = new Array();\nfor (var i = 0; i < 1200; i++) _2eXp[i] = Math.pow(2, i);\nvar _2eXn = new Array();\nfor (var i = 0; i < 1200; i++) _2eXn[i] = Math.pow(2, -i);\nfunction pow2(exp) {\n  return exp >= 0 ? _2eXp[exp] : _2eXn[-exp];\n  //return (exp >= 0) ? (exp <  31 ? (1 << exp) :        Math.pow(2, exp))\n  //                  : (exp > -31 ? (1 / (1 << -exp)) : Math.pow(2, exp));\n}\n\n// getFloat() from qbson, https://github.com/andrasq/node-qbson:\n/*\n * extract the 64-bit little-endian ieee 754 floating-point value\n *   see http://en.wikipedia.org/wiki/Double-precision_floating-point_format\n *   1 bit sign + 11 bits exponent + (1 implicit mantissa 1 bit) + 52 mantissa bits\n */\nvar _rshift32 = 1 / 0x100000000; // >> 32 for floats\nvar _rshift20 = 1 / 0x100000; // >> 20 for floats\nvar _lshift32 = 1 * 0x100000000; // << 32\nvar _rshift52 = 1 * _rshift32 * _rshift20; // >> 52\nvar _rshift1023 = pow2(-1023); // 2^-1023\nfunction readDouble(buf, offset, dirn) {\n  var w0 = readWord(buf, offset, dirn);\n  var w1 = readWord(buf, offset + 4, dirn);\n  var highWord, lowWord;\n  dirn === 'bige' ? (highWord = w0, lowWord = w1) : (highWord = w1, lowWord = w0);\n  var mantissa = (highWord & 0x000FFFFF) * _lshift32 + lowWord;\n  var exponent = (highWord & 0x7FF00000) >>> 20;\n  var sign = highWord >> 31 || 1; // -1, 1, or 1 if NaN\n\n  var value;\n  if (exponent === 0x000) {\n    // zero if !mantissa, else subnormal (non-normalized reduced precision small value)\n    // recover negative zero -0.0 as distinct from 0.0\n    // subnormals do not have an implied leading 1 bit and are positioned 1 bit to the left\n    value = mantissa ? mantissa * pow2(-52 + 1 - 1023) : 0.0;\n  } else if (exponent < 0x7ff) {\n    // normalized value with an implied leading 1 bit and 1023 biased exponent\n    // test for NaN with (mantissa >= 0), and return 0 if NaN ie read from outside buffer bounds\n    value = mantissa >= 0 ? (1 + mantissa * _rshift52) * pow2(exponent - 1023) : 0.0;\n  } else {\n    // Infinity if zero mantissa (+/- per sign), NaN if nonzero mantissa\n    value = mantissa ? NaN : Infinity;\n  }\n  return sign * value;\n}\n\n//\n// Note: node-v9 prefers +28% (sign * value), node v6 doesnt care, node v8 likes +16% (-value : value)\n//\n// float32: 1 sign + 8 exponent + 24 mantissa (23 stored, 1 implied)\n// see https://en.wikipedia.org/wiki/Single-precision_floating-point_format\n//\n// Exponent     Mantissa == 0   Mantissa > 0    Value\n// 00           +0, -0          denormalized    2^(  1-127) * (0. + (mantissa / 2^23))\n// 00.. FE                      normalized      2^(exp-127) * (1. + (mantissa / 2^23))\n// FF           +/-Infinity     NaN             -\n//\nvar _rshift23 = Math.pow(2, -23); // >> 23 for floats\nvar _rshift127 = Math.pow(2, -127); // 2^-127\nfunction readFloat(buf, offset, dirn) {\n  var word = readWord(buf, offset, dirn);\n  var mantissa = word & 0x007FFFFF;\n  var exponent = (word & 0x7F800000) >>> 23;\n  var sign = word >> 31 || 1; // -1, 1, or 1 if NaN\n\n  var value;\n  if (exponent === 0x000) {\n    value = mantissa ? mantissa * _rshift23 * 2 * _rshift127 : 0.0;\n  } else if (exponent < 0xff) {\n    value = (1 + mantissa * _rshift23) * pow2(exponent - 127); // * _rshift127;\n  } else {\n    value = mantissa ? NaN : Infinity;\n  }\n  return sign * value;\n  //return (word >>> 31) ? -value : value;\n}\n\n// given a positive value v, normalize it to between 1 and less than 2 with a binary exponent\n// The exponent is the number of bit places it was shifted, positive if v was >= 2.\n// The special values 0, -0, NaN, +Infinity and -Infinity are not handled here.\n// Looping is faster than (Math.log(v) / Math.LN2) in node-v6, v8, and v9.\n// This function can account for half the time taken to write a double.\nvar _parts = {\n  exp: 0,\n  mant: 0\n};\nfunction normalize(v) {\n  var exp = 0;\n  if (v >= 2) {\n    exp = countDoublings(1, v);\n    v *= pow2(-exp);\n    // if doubled to exactly v/2, adjust up to v\n    if (v >= 2) {\n      v /= 2;\n      exp += 1;\n    }\n  } else if (v < 1) {\n    exp = countDoublings(v, 2);\n    // avoid using pow2 exponents > 1023, they overflow to Infinity\n    if (exp <= 1023) v *= pow2(exp);else {\n      v *= pow2(exp - 100);\n      v *= pow2(100);\n    }\n    exp = -exp;\n  }\n\n  // TODO: pass in num bits, and normalize straight to mantissa / denorm\n\n  _parts.exp = exp;\n  _parts.mant = v;\n  return _parts;\n}\n\n// count how many doublings of a are needed for it be close to b.\n// Returns a shift count that grows (a) to at least (b/2) but less than (b).\n// Doubling 1 toward v ensures that (v >> n) >= 1 < 2,\n// and doubling from v toward 2 ensures that (v << n) >= 1 < 2.\nvar _2e192 = Math.pow(2, 192);\nfunction countDoublings(a, b) {\n  var n = 0;\n  while (a * _2e192 < b) {\n    a *= _2e192;\n    n += 192;\n  }\n  while (a * 0x10000000000000000 < b) {\n    a *= 0x10000000000000000;\n    n += 64;\n  }\n  while (a * 0x10000 < b) {\n    a *= 0x10000;\n    n += 16;\n  }\n  while (a * 0x40 < b) {\n    a *= 0x40;\n    n += 6;\n  }\n  while (a * 2 < b) {\n    a *= 2;\n    n += 1;\n  }\n  return n;\n}\n\n// round the fraction in v and scale up to scale = 2^n bits\n// https://blog.angularindepth.com/how-to-round-binary-fractions-625c8fa3a1af\n// Rounding can cause the scaled value to exceed 2^n.\nfunction roundMantissa(v, scale) {\n  v *= scale;\n  // round to nearest, but round a 0.5 tie to even (0.5 to 0.0 and 1.5 to 2.0)\n  // round all numbers with a fraction other than 1/2, and round up odd numbers with\n  return v - Math.floor(v) !== 0.5 || v & 1 ? v + 0.5 : v;\n}\n\n// float32: 1 sign + 8 exponent + (1 implied mantissa 1 bit) + 23 stored mantissa bits\n// NaN types: quiet Nan = x.ff.8xxx, signaling NaN = x.ff.0xx1 (msb zero, at least one other bit set)\n// JavaScript built-in NaN is the non-signaling 7fc00000, but arithmetic can yield a negative NaN ffc00000.\nfunction writeFloat(buf, v, offset, dirn) {\n  var norm,\n    word,\n    sign = 0;\n  if (v < 0) {\n    sign = 0x80000000;\n    v = -v;\n  }\n  if (!(v && v < Infinity)) {\n    if (v === 0) {\n      // -0, +0\n      word = 1 / v < 0 ? 0x80000000 : 0x00000000;\n    } else if (v === Infinity) {\n      // -Infinity, +Infinity\n      word = sign | 0x7F800000;\n    } else {\n      // NaN - positive, non-signaling\n      word = 0x7FC00000;\n    }\n    writeWord(buf, word, offset, dirn);\n  } else {\n    norm = normalize(v); // separate exponent and mantissa\n    norm.exp += 127; // bias exponent\n\n    if (norm.exp <= 0) {\n      // denormalized number\n      if (norm.exp <= -25) {\n        // too small, underflow to zero.  -24 might round up though.\n        norm.mant = 0;\n        norm.exp = 0;\n      } else {\n        // denormalize\n        norm.mant = roundMantissa(norm.mant, pow2(22 + norm.exp));\n        norm.exp = 0; // rounding can carry out and re-normalize the number\n        if (norm.mant >= 0x800000) {\n          norm.mant -= 0x800000;\n          norm.exp += 1;\n        }\n      }\n    } else {\n      norm.mant = roundMantissa(norm.mant - 1, 0x800000);\n      // if rounding overflowed into the hidden 1s place, hide it and adjust the exponent\n      if (norm.mant >= 0x800000) {\n        norm.mant -= 0x800000;\n        norm.exp += 1;\n      }\n      if (norm.exp > 254) {\n        // overflow to Infinity\n        norm.mant = 0;\n        norm.exp = 255;\n      }\n    }\n    word = sign | norm.exp << 23 | norm.mant;\n    writeWord(buf, word, offset, dirn);\n  }\n}\n\n// double64: 1 bit sign + 11 bits exponent + (1 implied mantissa 1 bit) + 52 stored mantissa bits\n// Writing doubles is simpler than floats, because the internal javascript 64-bit floats\n// are identical to the stored representation, and thus will not overflow or underflow.\nvar doubleArray = [0, 0, 0, 0, 0, 0, 0, 0];\nvar doubleBuf = new Uint8Array(8);\nvar _2e52 = Math.pow(2, 52);\nfunction writeDouble(buf, v, offset, dirn) {\n  var norm,\n    highWord,\n    lowWord,\n    sign = 0;\n  if (v < 0) {\n    sign = 0x80000000;\n    v = -v;\n  }\n  if (!(v && v < Infinity)) {\n    if (v === 0) {\n      // -0, +0\n      highWord = 1 / v < 0 ? 0x80000000 : 0;\n      lowWord = 0;\n    } else if (v === Infinity) {\n      // -Infinity, +Infinity\n      highWord = sign + 0x7FF00000;\n      lowWord = 0;\n    } else {\n      // NaN - positive, non-signaling\n      highWord = 0x7FF80000;\n      lowWord = 0;\n    }\n    writeDoubleWord(buf, highWord, lowWord, offset, dirn);\n  } else {\n    norm = normalize(v); // separate exponent and mantissa\n    norm.exp += 1023; // bias exponent\n\n    if (norm.exp <= 0) {\n      // denormalized\n      // JavaScript numbers can not hold values small enough to underflow\n      // and no need to round, all bits will be written\n      norm.mant *= pow2(51 + norm.exp);\n      norm.exp = 0;\n    } else {\n      // no need to round, all bits will be written\n      norm.mant = (norm.mant - 1) * _2e52;\n    }\n    highWord = sign | norm.exp << 20 | norm.mant / 0x100000000;\n    lowWord = norm.mant >>> 0;\n    writeDoubleWord(buf, highWord, lowWord, offset, dirn);\n  }\n}\n;\n(function install() {\n  var exports = typeof module === 'object' && module.exports || this;\n  exports.readWord = readWord;\n  exports.writeWord = writeWord;\n  exports.writeDoubleWord = writeDoubleWord;\n  exports.readFloat = readFloat;\n  exports.writeFloat = writeFloat;\n  exports.readDouble = readDouble;\n  exports.writeDouble = writeDouble;\n\n  // expose the implementation to the tests\n  exports._useFloatArray = function (yesno) {\n    exports._usingFloatArray = yesno;\n    if (yesno) {\n      // software conversion is faster for float32 than Float32Array\n      // Only read via Float32Array if yesno == 'full'.\n      if (yesno == 'full') exports.readFloatLE = isBigeCpu ? readFloat32ArrayRev : readFloat32Array;\n      exports.writeFloatLE = isBigeCpu ? writeFloat32ArrayRev : writeFloat32Array;\n      if (yesno == 'full') exports.readFloatBE = isBigeCpu ? readFloat32Array : readFloat32ArrayRev;\n      exports.writeFloatBE = isBigeCpu ? writeFloat32Array : writeFloat32ArrayRev;\n      exports.readDoubleLE = isBigeCpu ? readFloat64ArrayRev : readFloat64Array;\n      exports.writeDoubleLE = isBigeCpu ? writeFloat64ArrayRev : writeFloat64Array;\n      exports.readDoubleBE = isBigeCpu ? readFloat64Array : readFloat64ArrayRev;\n      exports.writeDoubleBE = isBigeCpu ? writeFloat64Array : writeFloat64ArrayRev;\n    } else {\n      exports._usingFloatArray = '';\n      exports.readFloatLE = function readFloatLE(buf, offset) {\n        return exports.readFloat(buf, offset || 0, 'le');\n      };\n      exports.writeFloatLE = function writeFloatLE(buf, v, offset) {\n        exports.writeFloat(buf, v, offset || 0, 'le');\n      };\n      exports.readFloatBE = function readFloatBE(buf, offset) {\n        return exports.readFloat(buf, offset || 0, 'bige');\n      };\n      exports.writeFloatBE = function writeFloatBE(buf, v, offset) {\n        exports.writeFloat(buf, v, offset || 0, 'bige');\n      };\n      exports.readDoubleLE = function readDoubleLE(buf, offset) {\n        return exports.readDouble(buf, offset || 0, 'le');\n      };\n      exports.writeDoubleLE = function writeDoubleLE(buf, v, offset) {\n        exports.writeDouble(buf, v, offset || 0, 'le');\n      };\n      exports.readDoubleBE = function readDoubleBE(buf, offset) {\n        return exports.readDouble(buf, offset || 0, 'bige');\n      };\n      exports.writeDoubleBE = function writeDoubleLE(buf, v, offset) {\n        exports.writeDouble(buf, v, offset || 0, 'bige');\n      };\n    }\n  };\n\n  // expose the cpu endianism to the tests\n  exports._getBigeCpu = function () {\n    return isBigeCpu;\n  };\n  exports._setBigeCpu = function (yesno) {\n    isBigeCpu = yesno;\n  };\n\n  // by default export the software conversion functions, then\n  // if available, convert by casting a FloatArray to a byte array\n  exports._useFloatArray(false);\n  exports._useFloatArray(readFloat32Array && readFloat64Array && 'fastest');\n\n  // accelerate access\n  install.prototype = exports;\n}).call(this);","map":{"version":3,"names":["isBigeCpu","readFloat32Array","writeFloat32Array","readFloat32ArrayRev","writeFloat32ArrayRev","readFloat64Array","writeFloat64Array","readFloat64ArrayRev","writeFloat64ArrayRev","Float32Array","_fp32","_b32","Uint8Array","buffer","buf","pos","length","v","Float64Array","_fp64","_b64","readWord","offs","dirn","a","b","c","d","writeWord","writeDoubleWord","hi","lo","_2eXp","Array","i","Math","pow","_2eXn","pow2","exp","_rshift32","_rshift20","_lshift32","_rshift52","_rshift1023","readDouble","offset","w0","w1","highWord","lowWord","mantissa","exponent","sign","value","NaN","Infinity","_rshift23","_rshift127","readFloat","word","_parts","mant","normalize","countDoublings","_2e192","n","roundMantissa","scale","floor","writeFloat","norm","doubleArray","doubleBuf","_2e52","writeDouble","install","exports","module","_useFloatArray","yesno","_usingFloatArray","readFloatLE","writeFloatLE","readFloatBE","writeFloatBE","readDoubleLE","writeDoubleLE","readDoubleBE","writeDoubleBE","_getBigeCpu","_setBigeCpu","prototype","call"],"sources":["/Users/germangurov/projects/wax_bot/node_modules/atomicassets/lib/float.js"],"sourcesContent":["/**\n * pure javascript functions to read and write 32-bit and 64-bit IEEE 754 floating-point\n *\n * Copyright (C) 2017-2019 Andras Radics\n * Licensed under the Apache License, Version 2.0\n */\n// removed buffer\n\n'use strict';\n\nvar isBigeCpu = false;\nvar readFloat32Array, writeFloat32Array, readFloat32ArrayRev, writeFloat32ArrayRev;\nvar readFloat64Array, writeFloat64Array, readFloat64ArrayRev, writeFloat64ArrayRev;\n\n\n// test FloatArray existence with && to not throw off code coverage\n(typeof Float32Array === 'function') && (function(){\n    var _fp32 = new Float32Array(1);\n    var _b32 = new Uint8Array(_fp32.buffer);\n\n    _fp32[0] = -1;\n    isBigeCpu = _b32[3] === 0;\n\n    readFloat32Array = function readFloat32Array( buf, pos ) {\n        pos = pos || 0;\n        if (pos < 0 || pos + 4 > buf.length) return 0;\n        _b32[0] = buf[pos++]; _b32[1] = buf[pos++]; _b32[2] = buf[pos++];_b32[3] = buf[pos];\n        //_b32[0] = buf[pos+0]; _b32[1] = buf[pos+1]; _b32[2] = buf[pos+2]; _b32[3] = buf[pos+3];\n        return _fp32[0];\n    }\n\n    readFloat32ArrayRev = function readFloat32ArrayRev( buf, pos ) {\n        pos = pos || 0;\n        if (pos < 0 || pos + 4 > buf.length) return 0;\n        _b32[3] = buf[pos++]; _b32[2] = buf[pos++]; _b32[1] = buf[pos++]; _b32[0] = buf[pos];\n        //_b32[3] = buf[pos+0]; _b32[2] = buf[pos+1]; _b32[1] = buf[pos+2]; _b32[0] = buf[pos+3];\n        return _fp32[0];\n    }\n\n    writeFloat32Array = function writeFloat32Array( buf, v, pos ) {\n        pos = pos || 0;\n        _fp32[0] = v;\n        buf[pos++] = _b32[0]; buf[pos++] = _b32[1]; buf[pos++] = _b32[2]; buf[pos] = _b32[3];\n        //buf[pos+0] = _b32[0]; buf[pos+1] = _b32[1]; buf[pos+2] = _b32[2]; buf[pos+3] = _b32[3];\n    }\n\n    writeFloat32ArrayRev = function writeFloat32ArrayRev( buf, v, pos ) {\n        pos = pos || 0;\n        _fp32[0] = v;\n        buf[pos++] = _b32[3]; buf[pos++] = _b32[2]; buf[pos++] = _b32[1]; buf[pos] = _b32[0];\n        //buf[pos+0] = _b32[3]; buf[pos+1] = _b32[2]; buf[pos+2] = _b32[1]; buf[pos+3] = _b32[0];\n    }\n})();\n\n(typeof Float64Array === 'function') && (function(){\n    var _fp64 = new Float64Array(1);\n    var _b64 = new Uint8Array(_fp64.buffer);\n\n    readFloat64Array = function readFloat64Array( buf, pos ) {\n        pos = pos || 0;\n        if (pos < 0 || pos + 8 > buf.length) return 0;\n        //_b64[0] = buf[pos++]; _b64[1] = buf[pos++]; _b64[2] = buf[pos++]; _b64[3] = buf[pos++];\n        //_b64[4] = buf[pos++]; _b64[5] = buf[pos++]; _b64[6] = buf[pos++]; _b64[7] = buf[pos];\n        _b64[0] = buf[pos+0]; _b64[1] = buf[pos+1]; _b64[2] = buf[pos+2]; _b64[3] = buf[pos+3];\n        _b64[4] = buf[pos+4]; _b64[5] = buf[pos+5]; _b64[6] = buf[pos+6]; _b64[7] = buf[pos+7];\n        return _fp64[0];\n    }\n\n    readFloat64ArrayRev = function readFloat64ArrayRev( buf, pos ) {\n        pos = pos || 0;\n        if (pos < 0 || pos + 8 > buf.length) return 0;\n        //_b64[7] = buf[pos++]; _b64[6] = buf[pos++]; _b64[5] = buf[pos++]; _b64[4] = buf[pos++];\n        //_b64[3] = buf[pos++]; _b64[2] = buf[pos++]; _b64[1] = buf[pos++]; _b64[0] = buf[pos];\n        _b64[7] = buf[pos+0]; _b64[6] = buf[pos+1]; _b64[5] = buf[pos+2]; _b64[4] = buf[pos+3];\n        _b64[3] = buf[pos+4]; _b64[2] = buf[pos+5]; _b64[1] = buf[pos+6]; _b64[0] = buf[pos+7];\n        return _fp64[0];\n    }\n\n    writeFloat64Array = function writeFloat64Array( buf, v, pos ) {\n        pos = pos || 0;\n        _fp64[0] = v;\n        buf[pos + 0] = _b64[0]; buf[pos + 1] = _b64[1]; buf[pos + 2] = _b64[2]; buf[pos + 3] = _b64[3];\n        buf[pos + 4] = _b64[4]; buf[pos + 5] = _b64[5]; buf[pos + 6] = _b64[6]; buf[pos + 7] = _b64[7];\n    }\n\n    writeFloat64ArrayRev = function writeFloat64ArrayRev( buf, v, pos ) {\n        pos = pos || 0;\n        _fp64[0] = v;\n        buf[pos + 0] = _b64[7]; buf[pos + 1] = _b64[6]; buf[pos + 2] = _b64[5]; buf[pos + 3] = _b64[4];\n        buf[pos + 4] = _b64[3]; buf[pos + 5] = _b64[2]; buf[pos + 6] = _b64[1]; buf[pos + 7] = _b64[0];\n    }\n})();\n\n\n// arithmetic operations preserve NaN, but logical ops (, >>, etc) convert them to zero\n// Assemble the word to generate NaN if any reads are undefined (outside the bounds of the array).\nfunction readWord( buf, offs, dirn ) {\n    var a = buf[offs++], b = buf[offs++], c = buf[offs++], d = buf[offs];\n    return (dirn === 'bige')\n        ? (((((a * 256) + b) * 256) + c) * 256) + d\n        : (((((d * 256) + c) * 256) + b) * 256) + a;\n}\n\nfunction writeWord( buf, v, offs, dirn ) {\n    var a = (v >>> 24) & 0xff, b = (v >> 16) & 0xff, c = (v >> 8) & 0xff, d = (v) & 0xff;\n    (dirn === 'bige')\n        ? (buf[offs++] = a, buf[offs++] = b, buf[offs++] = c, buf[offs] = d)\n        : (buf[offs++] = d, buf[offs++] = c, buf[offs++] = b, buf[offs] = a)\n}\n\n// write the two-word value [hi,lo] where hi holds the 32 msb bits and lo the 32 lsb bits\nfunction writeDoubleWord( buf, hi, lo, offs, dirn ) {\n    if (dirn === 'bige') {\n        writeWord(buf, hi, offs, dirn);\n        writeWord(buf, lo, offs + 4, dirn);\n    }\n    else {\n        writeWord(buf, lo, offs, dirn);\n        writeWord(buf, hi, offs + 4, dirn);\n    }\n}\n\n// given an exponent n, return 2**n\n// n is always an integer, faster to shift when possible\n// Note that nodejs Math.pow() is faster than a lookup table (may be caching)\nvar _2eXp = new Array(); for (var i=0; i<1200; i++) _2eXp[i] = Math.pow(2, i);\nvar _2eXn = new Array(); for (var i=0; i<1200; i++) _2eXn[i] = Math.pow(2, -i);\nfunction pow2( exp ) {\n    return (exp >= 0) ? _2eXp[exp] : _2eXn[-exp];\n    //return (exp >= 0) ? (exp <  31 ? (1 << exp) :        Math.pow(2, exp))\n    //                  : (exp > -31 ? (1 / (1 << -exp)) : Math.pow(2, exp));\n}\n\n\n// getFloat() from qbson, https://github.com/andrasq/node-qbson:\n/*\n * extract the 64-bit little-endian ieee 754 floating-point value\n *   see http://en.wikipedia.org/wiki/Double-precision_floating-point_format\n *   1 bit sign + 11 bits exponent + (1 implicit mantissa 1 bit) + 52 mantissa bits\n */\nvar _rshift32 = (1 / 0x100000000);      // >> 32 for floats\nvar _rshift20 = (1 / 0x100000);         // >> 20 for floats\nvar _lshift32 = (1 * 0x100000000);      // << 32\nvar _rshift52 = (1 * _rshift32 * _rshift20);    // >> 52\nvar _rshift1023 = pow2(-1023);          // 2^-1023\nfunction readDouble( buf, offset, dirn ) {\n    var w0 = readWord(buf, offset, dirn);\n    var w1 = readWord(buf, offset + 4, dirn);\n    var highWord, lowWord;\n    (dirn === 'bige') ? (highWord = w0, lowWord = w1) : (highWord = w1, lowWord = w0);\n\n    var mantissa = (highWord & 0x000FFFFF) * _lshift32 + lowWord;\n    var exponent = (highWord & 0x7FF00000) >>> 20;\n    var sign = (highWord >> 31) || 1;   // -1, 1, or 1 if NaN\n\n    var value;\n    if (exponent === 0x000) {\n        // zero if !mantissa, else subnormal (non-normalized reduced precision small value)\n        // recover negative zero -0.0 as distinct from 0.0\n        // subnormals do not have an implied leading 1 bit and are positioned 1 bit to the left\n        value = mantissa ? (mantissa * pow2(-52 + 1 -1023)) : 0.0;\n    }\n    else if (exponent < 0x7ff) {\n        // normalized value with an implied leading 1 bit and 1023 biased exponent\n        // test for NaN with (mantissa >= 0), and return 0 if NaN ie read from outside buffer bounds\n        value = (mantissa >= 0) ? (1 + mantissa * _rshift52) * pow2(exponent - 1023) : 0.0;\n    }\n    else {\n        // Infinity if zero mantissa (+/- per sign), NaN if nonzero mantissa\n        value = mantissa ? NaN : Infinity;\n    }\n\n    return sign * value;\n}\n\n//\n// Note: node-v9 prefers +28% (sign * value), node v6 doesnt care, node v8 likes +16% (-value : value)\n//\n// float32: 1 sign + 8 exponent + 24 mantissa (23 stored, 1 implied)\n// see https://en.wikipedia.org/wiki/Single-precision_floating-point_format\n//\n// Exponent     Mantissa == 0   Mantissa > 0    Value\n// 00           +0, -0          denormalized    2^(  1-127) * (0. + (mantissa / 2^23))\n// 00.. FE                      normalized      2^(exp-127) * (1. + (mantissa / 2^23))\n// FF           +/-Infinity     NaN             -\n//\nvar _rshift23 = Math.pow(2, -23);      // >> 23 for floats\nvar _rshift127 = Math.pow(2, -127);    // 2^-127\nfunction readFloat( buf, offset, dirn ) {\n    var word = readWord(buf, offset, dirn);\n    var mantissa = (word & 0x007FFFFF);\n    var exponent = (word & 0x7F800000) >>> 23;\n    var sign = (word >> 31) || 1;       // -1, 1, or 1 if NaN\n\n    var value;\n    if (exponent === 0x000) {\n        value = mantissa ? mantissa * _rshift23 * 2 * _rshift127 : 0.0;\n    }\n    else if (exponent < 0xff) {\n        value = (1 + mantissa * _rshift23) * pow2(exponent - 127) // * _rshift127;\n    }\n    else {\n        value = mantissa ? NaN : Infinity;\n    }\n\n    return sign * value;\n    //return (word >>> 31) ? -value : value;\n}\n\n// given a positive value v, normalize it to between 1 and less than 2 with a binary exponent\n// The exponent is the number of bit places it was shifted, positive if v was >= 2.\n// The special values 0, -0, NaN, +Infinity and -Infinity are not handled here.\n// Looping is faster than (Math.log(v) / Math.LN2) in node-v6, v8, and v9.\n// This function can account for half the time taken to write a double.\nvar _parts = { exp: 0, mant: 0 };\nfunction normalize( v ) {\n    var exp = 0;\n\n    if (v >= 2) {\n        exp = countDoublings(1, v);\n        v *= pow2(-exp);\n        // if doubled to exactly v/2, adjust up to v\n        if (v >= 2) { v /= 2; exp += 1 }\n    }\n    else if (v < 1) {\n        exp = countDoublings(v, 2);\n        // avoid using pow2 exponents > 1023, they overflow to Infinity\n        if (exp <= 1023) v *= pow2(exp);\n        else { v *= pow2(exp - 100); v *= pow2(100); }\n        exp = -exp;\n    }\n\n    // TODO: pass in num bits, and normalize straight to mantissa / denorm\n\n    _parts.exp = exp;\n    _parts.mant = v;\n    return _parts;\n}\n\n// count how many doublings of a are needed for it be close to b.\n// Returns a shift count that grows (a) to at least (b/2) but less than (b).\n// Doubling 1 toward v ensures that (v >> n) >= 1 < 2,\n// and doubling from v toward 2 ensures that (v << n) >= 1 < 2.\nvar _2e192 = Math.pow(2, 192);\nfunction countDoublings( a, b ) {\n    var n = 0;\n\n    while (a * _2e192 < b) { a *= _2e192; n += 192 }\n    while (a * 0x10000000000000000 < b) { a *= 0x10000000000000000; n += 64 }\n    while (a * 0x10000 < b) { a *= 0x10000; n += 16 }\n    while (a * 0x40 < b) { a *= 0x40; n += 6 }\n    while (a * 2 < b) { a *= 2; n += 1 }\n\n    return n;\n}\n\n// round the fraction in v and scale up to scale = 2^n bits\n// https://blog.angularindepth.com/how-to-round-binary-fractions-625c8fa3a1af\n// Rounding can cause the scaled value to exceed 2^n.\nfunction roundMantissa( v, scale ) {\n    v *= scale;\n    // round to nearest, but round a 0.5 tie to even (0.5 to 0.0 and 1.5 to 2.0)\n    // round all numbers with a fraction other than 1/2, and round up odd numbers with\n    return ((v - Math.floor(v) !== 0.5) || (v & 1)) ? v + 0.5 : v;\n}\n\n// float32: 1 sign + 8 exponent + (1 implied mantissa 1 bit) + 23 stored mantissa bits\n// NaN types: quiet Nan = x.ff.8xxx, signaling NaN = x.ff.0xx1 (msb zero, at least one other bit set)\n// JavaScript built-in NaN is the non-signaling 7fc00000, but arithmetic can yield a negative NaN ffc00000.\nfunction writeFloat( buf, v, offset, dirn ) {\n    var norm, word, sign = 0;\n    if (v < 0) { sign = 0x80000000; v = -v; }\n\n    if (! (v && v < Infinity)) {\n        if (v === 0) {                  // -0, +0\n            word = (1/v < 0) ? 0x80000000 : 0x00000000;\n        }\n        else if (v === Infinity) {      // -Infinity, +Infinity\n            word = sign | 0x7F800000;\n        }\n        else {                          // NaN - positive, non-signaling\n            word = 0x7FC00000;\n        }\n        writeWord(buf, word, offset, dirn);\n    }\n    else {\n        norm = normalize(v);            // separate exponent and mantissa\n        norm.exp += 127;                // bias exponent\n\n        if (norm.exp <= 0) {            // denormalized number\n            if (norm.exp <= -25) {      // too small, underflow to zero.  -24 might round up though.\n                norm.mant = 0;\n                norm.exp = 0;\n            } else {                    // denormalize\n                norm.mant = roundMantissa(norm.mant, pow2(22 + norm.exp));\n                norm.exp = 0;           // rounding can carry out and re-normalize the number\n                if (norm.mant >= 0x800000) { norm.mant -= 0x800000; norm.exp += 1 }\n            }\n        } else {\n            norm.mant = roundMantissa(norm.mant - 1, 0x800000);\n            // if rounding overflowed into the hidden 1s place, hide it and adjust the exponent\n            if (norm.mant >= 0x800000) { norm.mant -= 0x800000; norm.exp += 1 }\n            if (norm.exp > 254) {       // overflow to Infinity\n                norm.mant = 0;\n                norm.exp = 255;\n            }\n        }\n\n        word = sign | (norm.exp << 23) | norm.mant;\n        writeWord(buf, word, offset, dirn);\n    }\n}\n\n// double64: 1 bit sign + 11 bits exponent + (1 implied mantissa 1 bit) + 52 stored mantissa bits\n// Writing doubles is simpler than floats, because the internal javascript 64-bit floats\n// are identical to the stored representation, and thus will not overflow or underflow.\nvar doubleArray = [0, 0, 0, 0, 0, 0, 0, 0];\nvar doubleBuf = new Uint8Array(8);\nvar _2e52 = Math.pow(2, 52);\nfunction writeDouble( buf, v, offset, dirn ) {\n    var norm, highWord, lowWord, sign = 0;\n    if (v < 0) { sign = 0x80000000; v = -v; }\n\n    if (! (v && v < Infinity)) {\n        if (v === 0) {                  // -0, +0\n            highWord = (1/v < 0) ? 0x80000000 : 0;\n            lowWord = 0;\n        }\n        else if (v === Infinity) {      // -Infinity, +Infinity\n            highWord = (sign + 0x7FF00000);\n            lowWord = 0;\n        }\n        else {                          // NaN - positive, non-signaling\n            highWord = 0x7FF80000;\n            lowWord = 0;\n        }\n        writeDoubleWord(buf, highWord, lowWord, offset, dirn);\n    }\n    else {\n        norm = normalize(v);            // separate exponent and mantissa\n        norm.exp += 1023;               // bias exponent\n\n        if (norm.exp <= 0) {            // denormalized\n            // JavaScript numbers can not hold values small enough to underflow\n            // and no need to round, all bits will be written\n            norm.mant *= pow2(51 + norm.exp);\n            norm.exp = 0;\n        }\n        else {\n            // no need to round, all bits will be written\n            norm.mant = (norm.mant - 1) * _2e52;\n        }\n\n        highWord = sign | (norm.exp << 20) | (norm.mant / 0x100000000);\n        lowWord = norm.mant >>> 0;\n        writeDoubleWord(buf, highWord, lowWord, offset, dirn);\n    }\n}\n\n\n;(function install() {\n    var exports = typeof module === 'object' && module.exports || this;\n\n    exports.readWord = readWord;\n    exports.writeWord = writeWord;\n    exports.writeDoubleWord = writeDoubleWord;\n\n    exports.readFloat = readFloat;\n    exports.writeFloat = writeFloat;\n    exports.readDouble = readDouble;\n    exports.writeDouble = writeDouble;\n\n    // expose the implementation to the tests\n    exports._useFloatArray = function( yesno ) {\n        exports._usingFloatArray = yesno;\n        if (yesno) {\n            // software conversion is faster for float32 than Float32Array\n            // Only read via Float32Array if yesno == 'full'.\n            if (yesno == 'full') exports.readFloatLE = isBigeCpu ? readFloat32ArrayRev : readFloat32Array;\n            exports.writeFloatLE = isBigeCpu ? writeFloat32ArrayRev : writeFloat32Array;\n            if (yesno == 'full') exports.readFloatBE = isBigeCpu ? readFloat32Array : readFloat32ArrayRev;\n            exports.writeFloatBE = isBigeCpu ? writeFloat32Array : writeFloat32ArrayRev;\n\n            exports.readDoubleLE = isBigeCpu ? readFloat64ArrayRev : readFloat64Array;\n            exports.writeDoubleLE = isBigeCpu ? writeFloat64ArrayRev : writeFloat64Array;\n            exports.readDoubleBE = isBigeCpu ? readFloat64Array : readFloat64ArrayRev;\n            exports.writeDoubleBE = isBigeCpu ? writeFloat64Array : writeFloat64ArrayRev;\n        }\n        else {\n            exports._usingFloatArray = '';\n            exports.readFloatLE = function readFloatLE( buf, offset ) { return exports.readFloat(buf, offset || 0, 'le'); }\n            exports.writeFloatLE = function writeFloatLE( buf, v, offset ) { exports.writeFloat(buf, v, offset || 0, 'le'); };\n            exports.readFloatBE = function readFloatBE( buf, offset ) { return exports.readFloat(buf, offset || 0, 'bige'); }\n            exports.writeFloatBE = function writeFloatBE( buf, v, offset ) { exports.writeFloat(buf, v, offset || 0, 'bige'); }\n\n            exports.readDoubleLE = function readDoubleLE( buf, offset ) { return exports.readDouble(buf, offset || 0, 'le'); }\n            exports.writeDoubleLE = function writeDoubleLE( buf, v, offset ) { exports.writeDouble(buf, v, offset || 0, 'le'); }\n            exports.readDoubleBE = function readDoubleBE( buf, offset ) { return exports.readDouble(buf, offset || 0, 'bige'); }\n            exports.writeDoubleBE = function writeDoubleLE( buf, v, offset ) { exports.writeDouble(buf, v, offset || 0, 'bige'); }\n        }\n    }\n\n    // expose the cpu endianism to the tests\n    exports._getBigeCpu = function() { return isBigeCpu };\n    exports._setBigeCpu = function(yesno) { isBigeCpu = yesno };\n\n    // by default export the software conversion functions, then\n    // if available, convert by casting a FloatArray to a byte array\n    exports._useFloatArray(false);\n    exports._useFloatArray(readFloat32Array && readFloat64Array && 'fastest');\n\n    // accelerate access\n    install.prototype = exports;\n\n}).call(this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}