{"ast":null,"code":"const _ = require('lodash');\nconst ORDER_TYPES = require('../consts/ORDER_TYPES');\nconst fetchAccount = require('./fetchAccount');\nconst fetchMarketOrders = require('./fetchMarketOrders');\nconst findTokenBalance = ({\n  tokenBalances,\n  tokenName\n}) => {\n  return tokenBalances.find(b => b.fullTokenName === tokenName);\n};\nconst fetchDexWithOrders = async ({\n  accountName,\n  tokens,\n  cache = {}\n}) => {\n  if (tokens.length < 2 || tokens.length > 2) {\n    throw new Error(`Number of tokens should be 2`);\n  }\n  if (tokens[0] === tokens[1]) {\n    throw new Error(`Tokens must be different`);\n  }\n  const account = cache.account || (await fetchAccount({\n    accountName\n  }));\n  const tokenBalances = _(tokens).map(tokenName => {\n    const tokenBalance = findTokenBalance({\n      tokenBalances: account.balance,\n      tokenName\n    });\n    if (tokenBalance == null) {\n      throw new Error(`Token ${tokenName} balance hasn't been registered`);\n    }\n    return tokenBalance;\n  }).value();\n  const dex = _(tokenBalances[0].dexs).find(dex => _(tokens).every(token => dex.symbols.find(s => s.fullTokenName === token)));\n  if (dex == null) {\n    throw new Error(`No DEX for pair ${tokens[0]}/${tokens[1]} has been found`);\n  }\n  if (dex.isFrozen === 1) {\n    throw new Error(`DEX ${tokens[0]}/${tokens[1]} is frozen`);\n  }\n\n  // buy orders\n  const buyOrders = await fetchMarketOrders({\n    dexId: dex.id,\n    orderType: ORDER_TYPES.BUY\n  });\n  const accountBuyOrders = _(buyOrders).filter(order => order.account === accountName).value();\n  const otherBuyOrders = _(buyOrders).filter(order => order.account !== accountName).value();\n  const accountMaxUnitPrice = _(accountBuyOrders).map(order => order.unitPrice).max();\n  const otherMaxUnitPrice = _(otherBuyOrders).map(order => order.unitPrice).max();\n\n  // sell orders\n  const sellOrders = await fetchMarketOrders({\n    dexId: dex.id,\n    orderType: ORDER_TYPES.SELL\n  });\n  const accountSellOrders = _(sellOrders).filter(order => order.account === accountName).value();\n  const otherSellOrders = _(sellOrders).filter(order => order.account !== accountName).value();\n  const accountMinUnitPrice = _(accountSellOrders).map(order => order.unitPrice).min();\n  const otherMinUnitPrice = _(otherSellOrders).map(order => order.unitPrice).min();\n\n  // tokens\n  const baseToken = dex.symbols[0];\n  const baseTokenBalance = findTokenBalance({\n    tokenBalances,\n    tokenName: baseToken.fullTokenName\n  });\n  const quoteToken = dex.symbols[1];\n  const quoteTokenBalance = findTokenBalance({\n    tokenBalances,\n    tokenName: quoteToken.fullTokenName\n  });\n  const dexInfo = {\n    account,\n    dex,\n    baseToken: {\n      fullTokenName: baseToken.fullTokenName,\n      tokenName: baseToken.symbol,\n      contract: baseToken.contract,\n      precision: baseToken.precision,\n      minPriceUnit: baseToken.min,\n      accountAmount: baseTokenBalance.amount\n    },\n    quoteToken: {\n      fullTokenName: quoteToken.fullTokenName,\n      tokenName: quoteToken.symbol,\n      contract: quoteToken.contract,\n      precision: quoteToken.precision,\n      minPriceUnit: quoteToken.min,\n      accountAmount: quoteTokenBalance.amount\n    },\n    buyOrders: {\n      accountMaxUnitPrice,\n      otherMaxUnitPrice,\n      priceDiff: accountMaxUnitPrice == null ? null : (accountMaxUnitPrice - otherMaxUnitPrice) / otherMaxUnitPrice,\n      quotePriceDiff: accountMaxUnitPrice == null ? null : accountMaxUnitPrice - otherMaxUnitPrice,\n      accountOrders: accountBuyOrders,\n      otherOrders: otherBuyOrders,\n      orders: buyOrders\n    },\n    sellOrders: {\n      accountMinUnitPrice,\n      otherMinUnitPrice,\n      priceDiff: accountMinUnitPrice == null ? null : (otherMinUnitPrice - accountMinUnitPrice) / otherMinUnitPrice,\n      quotePriceDiff: accountMinUnitPrice == null ? null : otherMinUnitPrice - accountMinUnitPrice,\n      accountOrders: accountSellOrders,\n      otherOrders: otherSellOrders,\n      orders: sellOrders\n    }\n  };\n  return dexInfo;\n};\nmodule.exports = fetchDexWithOrders;","map":{"version":3,"names":["_","require","ORDER_TYPES","fetchAccount","fetchMarketOrders","findTokenBalance","tokenBalances","tokenName","find","b","fullTokenName","fetchDexWithOrders","accountName","tokens","cache","length","Error","account","map","tokenBalance","balance","value","dex","dexs","every","token","symbols","s","isFrozen","buyOrders","dexId","id","orderType","BUY","accountBuyOrders","filter","order","otherBuyOrders","accountMaxUnitPrice","unitPrice","max","otherMaxUnitPrice","sellOrders","SELL","accountSellOrders","otherSellOrders","accountMinUnitPrice","min","otherMinUnitPrice","baseToken","baseTokenBalance","quoteToken","quoteTokenBalance","dexInfo","symbol","contract","precision","minPriceUnit","accountAmount","amount","priceDiff","quotePriceDiff","accountOrders","otherOrders","orders","module","exports"],"sources":["/Users/germangurov/projects/wax_bot/src/alcor/api/fetchDexWithOrders.js"],"sourcesContent":["const _ = require('lodash');\nconst ORDER_TYPES = require('../consts/ORDER_TYPES');\nconst fetchAccount = require('./fetchAccount');\nconst fetchMarketOrders = require('./fetchMarketOrders');\n\nconst findTokenBalance = ({\n    tokenBalances,\n    tokenName,\n}) => {\n    return tokenBalances.find(b => b.fullTokenName === tokenName);\n};\n\nconst fetchDexWithOrders = async ({\n    accountName,\n    tokens,\n    cache = {},\n}) => {\n    if (tokens.length < 2 || tokens.length > 2) {\n        throw new Error(`Number of tokens should be 2`);\n    }\n    if (tokens[0] === tokens[1]) {\n        throw new Error(`Tokens must be different`);\n    }\n\n    const account = cache.account || await fetchAccount({accountName});\n    const tokenBalances = _(tokens)\n        .map(tokenName => {\n            const tokenBalance = findTokenBalance({\n                tokenBalances: account.balance,\n                tokenName,\n            });\n\n            if (tokenBalance == null) {\n                throw new Error(`Token ${tokenName} balance hasn't been registered`);\n            }\n\n            return tokenBalance;\n        })\n        .value();\n\n    const dex = _(tokenBalances[0].dexs)\n        .find(dex => _(tokens)\n            .every(token =>  dex.symbols.find(s => s.fullTokenName === token))\n        );\n    if (dex == null) {\n        throw new Error(`No DEX for pair ${tokens[0]}/${tokens[1]} has been found`);\n    }\n\n    if (dex.isFrozen === 1) {\n        throw new Error(`DEX ${tokens[0]}/${tokens[1]} is frozen`);\n    }\n\n    // buy orders\n    const buyOrders = await fetchMarketOrders({\n        dexId: dex.id,\n        orderType: ORDER_TYPES.BUY,\n    });\n    const accountBuyOrders = _(buyOrders)\n        .filter(order => order.account === accountName)\n        .value();\n    const otherBuyOrders = _(buyOrders)\n        .filter(order => order.account !== accountName)\n        .value();\n    const accountMaxUnitPrice = _(accountBuyOrders)\n        .map(order => order.unitPrice)\n        .max();\n    const otherMaxUnitPrice = _(otherBuyOrders)\n        .map(order => order.unitPrice)\n        .max();\n\n    // sell orders\n    const sellOrders = await fetchMarketOrders({\n        dexId: dex.id,\n        orderType: ORDER_TYPES.SELL,\n    });\n    const accountSellOrders = _(sellOrders)\n        .filter(order => order.account === accountName)\n        .value();\n    const otherSellOrders = _(sellOrders)\n        .filter(order => order.account !== accountName)\n        .value();\n    const accountMinUnitPrice = _(accountSellOrders)\n        .map(order => order.unitPrice)\n        .min();\n    const otherMinUnitPrice = _(otherSellOrders)\n        .map(order => order.unitPrice)\n        .min();\n\n    // tokens\n    const baseToken = dex.symbols[0];\n    const baseTokenBalance = findTokenBalance({\n        tokenBalances,\n        tokenName: baseToken.fullTokenName,\n    });\n    const quoteToken = dex.symbols[1];\n    const quoteTokenBalance = findTokenBalance({\n        tokenBalances,\n        tokenName: quoteToken.fullTokenName,\n    });\n\n    const dexInfo = {\n        account,\n        dex,\n        baseToken: {\n            fullTokenName: baseToken.fullTokenName,\n            tokenName: baseToken.symbol,\n            contract: baseToken.contract,\n            precision: baseToken.precision,\n            minPriceUnit: baseToken.min,\n            accountAmount: baseTokenBalance.amount,\n        },\n        quoteToken: {\n            fullTokenName: quoteToken.fullTokenName,\n            tokenName: quoteToken.symbol,\n            contract: quoteToken.contract,\n            precision: quoteToken.precision,\n            minPriceUnit: quoteToken.min,\n            accountAmount: quoteTokenBalance.amount,\n        },\n        buyOrders: {\n            accountMaxUnitPrice,\n            otherMaxUnitPrice,\n            priceDiff: accountMaxUnitPrice == null\n                ? null\n                : (accountMaxUnitPrice - otherMaxUnitPrice) / otherMaxUnitPrice,\n            quotePriceDiff: accountMaxUnitPrice == null\n                ? null\n                : accountMaxUnitPrice - otherMaxUnitPrice,\n            accountOrders: accountBuyOrders,\n            otherOrders: otherBuyOrders,\n            orders: buyOrders,\n        },\n        sellOrders: {\n            accountMinUnitPrice,\n            otherMinUnitPrice,\n            priceDiff: accountMinUnitPrice == null\n                ? null\n                : (otherMinUnitPrice - accountMinUnitPrice) / otherMinUnitPrice,\n            quotePriceDiff: accountMinUnitPrice == null\n                ? null\n                : otherMinUnitPrice - accountMinUnitPrice,\n            accountOrders: accountSellOrders,\n            otherOrders: otherSellOrders,\n            orders: sellOrders,\n        },\n    };\n    return dexInfo;\n};\n\nmodule.exports = fetchDexWithOrders;"],"mappings":"AAAA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAC3B,MAAMC,WAAW,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AACpD,MAAME,YAAY,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AAC9C,MAAMG,iBAAiB,GAAGH,OAAO,CAAC,qBAAqB,CAAC;AAExD,MAAMI,gBAAgB,GAAGA,CAAC;EACtBC,aAAa;EACbC;AACJ,CAAC,KAAK;EACF,OAAOD,aAAa,CAACE,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,aAAa,KAAKH,SAAS,CAAC;AACjE,CAAC;AAED,MAAMI,kBAAkB,GAAG,MAAAA,CAAO;EAC9BC,WAAW;EACXC,MAAM;EACNC,KAAK,GAAG,CAAC;AACb,CAAC,KAAK;EACF,IAAID,MAAM,CAACE,MAAM,GAAG,CAAC,IAAIF,MAAM,CAACE,MAAM,GAAG,CAAC,EAAE;IACxC,MAAM,IAAIC,KAAK,CAAE,8BAA6B,CAAC;EACnD;EACA,IAAIH,MAAM,CAAC,CAAC,CAAC,KAAKA,MAAM,CAAC,CAAC,CAAC,EAAE;IACzB,MAAM,IAAIG,KAAK,CAAE,0BAAyB,CAAC;EAC/C;EAEA,MAAMC,OAAO,GAAGH,KAAK,CAACG,OAAO,KAAI,MAAMd,YAAY,CAAC;IAACS;EAAW,CAAC,CAAC;EAClE,MAAMN,aAAa,GAAGN,CAAC,CAACa,MAAM,CAAC,CAC1BK,GAAG,CAACX,SAAS,IAAI;IACd,MAAMY,YAAY,GAAGd,gBAAgB,CAAC;MAClCC,aAAa,EAAEW,OAAO,CAACG,OAAO;MAC9Bb;IACJ,CAAC,CAAC;IAEF,IAAIY,YAAY,IAAI,IAAI,EAAE;MACtB,MAAM,IAAIH,KAAK,CAAE,SAAQT,SAAU,iCAAgC,CAAC;IACxE;IAEA,OAAOY,YAAY;EACvB,CAAC,CAAC,CACDE,KAAK,CAAC,CAAC;EAEZ,MAAMC,GAAG,GAAGtB,CAAC,CAACM,aAAa,CAAC,CAAC,CAAC,CAACiB,IAAI,CAAC,CAC/Bf,IAAI,CAACc,GAAG,IAAItB,CAAC,CAACa,MAAM,CAAC,CACjBW,KAAK,CAACC,KAAK,IAAKH,GAAG,CAACI,OAAO,CAAClB,IAAI,CAACmB,CAAC,IAAIA,CAAC,CAACjB,aAAa,KAAKe,KAAK,CAAC,CACrE,CAAC;EACL,IAAIH,GAAG,IAAI,IAAI,EAAE;IACb,MAAM,IAAIN,KAAK,CAAE,mBAAkBH,MAAM,CAAC,CAAC,CAAE,IAAGA,MAAM,CAAC,CAAC,CAAE,iBAAgB,CAAC;EAC/E;EAEA,IAAIS,GAAG,CAACM,QAAQ,KAAK,CAAC,EAAE;IACpB,MAAM,IAAIZ,KAAK,CAAE,OAAMH,MAAM,CAAC,CAAC,CAAE,IAAGA,MAAM,CAAC,CAAC,CAAE,YAAW,CAAC;EAC9D;;EAEA;EACA,MAAMgB,SAAS,GAAG,MAAMzB,iBAAiB,CAAC;IACtC0B,KAAK,EAAER,GAAG,CAACS,EAAE;IACbC,SAAS,EAAE9B,WAAW,CAAC+B;EAC3B,CAAC,CAAC;EACF,MAAMC,gBAAgB,GAAGlC,CAAC,CAAC6B,SAAS,CAAC,CAChCM,MAAM,CAACC,KAAK,IAAIA,KAAK,CAACnB,OAAO,KAAKL,WAAW,CAAC,CAC9CS,KAAK,CAAC,CAAC;EACZ,MAAMgB,cAAc,GAAGrC,CAAC,CAAC6B,SAAS,CAAC,CAC9BM,MAAM,CAACC,KAAK,IAAIA,KAAK,CAACnB,OAAO,KAAKL,WAAW,CAAC,CAC9CS,KAAK,CAAC,CAAC;EACZ,MAAMiB,mBAAmB,GAAGtC,CAAC,CAACkC,gBAAgB,CAAC,CAC1ChB,GAAG,CAACkB,KAAK,IAAIA,KAAK,CAACG,SAAS,CAAC,CAC7BC,GAAG,CAAC,CAAC;EACV,MAAMC,iBAAiB,GAAGzC,CAAC,CAACqC,cAAc,CAAC,CACtCnB,GAAG,CAACkB,KAAK,IAAIA,KAAK,CAACG,SAAS,CAAC,CAC7BC,GAAG,CAAC,CAAC;;EAEV;EACA,MAAME,UAAU,GAAG,MAAMtC,iBAAiB,CAAC;IACvC0B,KAAK,EAAER,GAAG,CAACS,EAAE;IACbC,SAAS,EAAE9B,WAAW,CAACyC;EAC3B,CAAC,CAAC;EACF,MAAMC,iBAAiB,GAAG5C,CAAC,CAAC0C,UAAU,CAAC,CAClCP,MAAM,CAACC,KAAK,IAAIA,KAAK,CAACnB,OAAO,KAAKL,WAAW,CAAC,CAC9CS,KAAK,CAAC,CAAC;EACZ,MAAMwB,eAAe,GAAG7C,CAAC,CAAC0C,UAAU,CAAC,CAChCP,MAAM,CAACC,KAAK,IAAIA,KAAK,CAACnB,OAAO,KAAKL,WAAW,CAAC,CAC9CS,KAAK,CAAC,CAAC;EACZ,MAAMyB,mBAAmB,GAAG9C,CAAC,CAAC4C,iBAAiB,CAAC,CAC3C1B,GAAG,CAACkB,KAAK,IAAIA,KAAK,CAACG,SAAS,CAAC,CAC7BQ,GAAG,CAAC,CAAC;EACV,MAAMC,iBAAiB,GAAGhD,CAAC,CAAC6C,eAAe,CAAC,CACvC3B,GAAG,CAACkB,KAAK,IAAIA,KAAK,CAACG,SAAS,CAAC,CAC7BQ,GAAG,CAAC,CAAC;;EAEV;EACA,MAAME,SAAS,GAAG3B,GAAG,CAACI,OAAO,CAAC,CAAC,CAAC;EAChC,MAAMwB,gBAAgB,GAAG7C,gBAAgB,CAAC;IACtCC,aAAa;IACbC,SAAS,EAAE0C,SAAS,CAACvC;EACzB,CAAC,CAAC;EACF,MAAMyC,UAAU,GAAG7B,GAAG,CAACI,OAAO,CAAC,CAAC,CAAC;EACjC,MAAM0B,iBAAiB,GAAG/C,gBAAgB,CAAC;IACvCC,aAAa;IACbC,SAAS,EAAE4C,UAAU,CAACzC;EAC1B,CAAC,CAAC;EAEF,MAAM2C,OAAO,GAAG;IACZpC,OAAO;IACPK,GAAG;IACH2B,SAAS,EAAE;MACPvC,aAAa,EAAEuC,SAAS,CAACvC,aAAa;MACtCH,SAAS,EAAE0C,SAAS,CAACK,MAAM;MAC3BC,QAAQ,EAAEN,SAAS,CAACM,QAAQ;MAC5BC,SAAS,EAAEP,SAAS,CAACO,SAAS;MAC9BC,YAAY,EAAER,SAAS,CAACF,GAAG;MAC3BW,aAAa,EAAER,gBAAgB,CAACS;IACpC,CAAC;IACDR,UAAU,EAAE;MACRzC,aAAa,EAAEyC,UAAU,CAACzC,aAAa;MACvCH,SAAS,EAAE4C,UAAU,CAACG,MAAM;MAC5BC,QAAQ,EAAEJ,UAAU,CAACI,QAAQ;MAC7BC,SAAS,EAAEL,UAAU,CAACK,SAAS;MAC/BC,YAAY,EAAEN,UAAU,CAACJ,GAAG;MAC5BW,aAAa,EAAEN,iBAAiB,CAACO;IACrC,CAAC;IACD9B,SAAS,EAAE;MACPS,mBAAmB;MACnBG,iBAAiB;MACjBmB,SAAS,EAAEtB,mBAAmB,IAAI,IAAI,GAChC,IAAI,GACJ,CAACA,mBAAmB,GAAGG,iBAAiB,IAAIA,iBAAiB;MACnEoB,cAAc,EAAEvB,mBAAmB,IAAI,IAAI,GACrC,IAAI,GACJA,mBAAmB,GAAGG,iBAAiB;MAC7CqB,aAAa,EAAE5B,gBAAgB;MAC/B6B,WAAW,EAAE1B,cAAc;MAC3B2B,MAAM,EAAEnC;IACZ,CAAC;IACDa,UAAU,EAAE;MACRI,mBAAmB;MACnBE,iBAAiB;MACjBY,SAAS,EAAEd,mBAAmB,IAAI,IAAI,GAChC,IAAI,GACJ,CAACE,iBAAiB,GAAGF,mBAAmB,IAAIE,iBAAiB;MACnEa,cAAc,EAAEf,mBAAmB,IAAI,IAAI,GACrC,IAAI,GACJE,iBAAiB,GAAGF,mBAAmB;MAC7CgB,aAAa,EAAElB,iBAAiB;MAChCmB,WAAW,EAAElB,eAAe;MAC5BmB,MAAM,EAAEtB;IACZ;EACJ,CAAC;EACD,OAAOW,OAAO;AAClB,CAAC;AAEDY,MAAM,CAACC,OAAO,GAAGvD,kBAAkB"},"metadata":{},"sourceType":"module","externalDependencies":[]}