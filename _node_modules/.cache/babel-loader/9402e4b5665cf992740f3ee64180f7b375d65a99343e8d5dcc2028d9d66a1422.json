{"ast":null,"code":"const _ = require('lodash');\nconst bn = require('big-number');\nconst fetchDexWithOrders = require('./api/fetchDexWithOrders');\nconst formatPriceUnit = require('./utils/formatPriceUnit');\nconst announceMarketTokensSale = require('./actions/announceMarketTokensSale');\nconst cancelMarketTokensSale = require('./actions/cancelMarketTokensSale');\nconst ORDER_TYPES = require('./consts/ORDER_TYPES');\nconst logMessage = require('./utils/logMessage');\nconst cancelMarketTokenOrder = ({\n  orders\n}) => {\n  return _(orders).map(order => cancelMarketTokensSale({\n    accountName: order.account,\n    dexId: order.dexId,\n    orderId: order.id,\n    orderType: ORDER_TYPES.SELL\n  })).flatten().value();\n};\nconst calcQuoteUnit = ({\n  quoteUnit,\n  currentBalance,\n  targetBalance = 0\n}) => {\n  if (currentBalance - quoteUnit >= targetBalance) {\n    return quoteUnit;\n  }\n  const diff = currentBalance - targetBalance;\n  if (diff < 0) {\n    return 0;\n  }\n  return _.floor(diff);\n};\nconst sendMarketSellOrderCalcNextAction = async ({\n  accountName,\n  gameSettings: {\n    orderSettings: {\n      tokens,\n      quoteUnit,\n      minUnitPrice,\n      targetBalance,\n      fixMinPrice\n    },\n    account = null\n  }\n}) => {\n  if (quoteUnit == null) {\n    throw new Error(`\"orderSettings\" should have \"quoteUnit\" declared`);\n  }\n  if (tokens == null) {\n    throw new Error(`\"orderSettings\" should have \"tokens\" declared`);\n  }\n  if (minUnitPrice == null) {\n    throw new Error(`\"orderSettings\" should have \"minUnitPrice\" declared`);\n  }\n  const dexWithOrders = await fetchDexWithOrders({\n    accountName,\n    tokens,\n    cache: {\n      account\n    }\n  });\n  const {\n    quoteToken,\n    baseToken\n  } = dexWithOrders;\n  const {\n    accountMinUnitPrice,\n    otherMinUnitPrice,\n    priceDiff,\n    quotePriceDiff,\n    accountOrders\n  } = dexWithOrders.sellOrders;\n  const effectiveQuoteUnit = calcQuoteUnit({\n    quoteUnit,\n    targetBalance,\n    currentBalance: quoteToken.accountAmount\n  });\n  const hasOrders = accountOrders.length > 0;\n  console.log('>>>>', hasOrders, quoteUnit, effectiveQuoteUnit, quoteToken.accountAmount, targetBalance, priceDiff, quotePriceDiff);\n  if (hasOrders && accountMinUnitPrice < minUnitPrice) {\n    return {\n      action: 'cancel_cheap_orders',\n      message: logMessage({\n        quoteToken,\n        baseToken,\n        message: `Canceling cheap orders (price=${accountMinUnitPrice}, min_price=${minUnitPrice})`\n      }),\n      actions: cancelMarketTokenOrder({\n        orders: accountOrders\n      })\n    };\n  }\n  if (hasOrders && quotePriceDiff > 1) {\n    return {\n      action: 'cancel_overpriced_orders',\n      message: logMessage({\n        quoteToken,\n        baseToken,\n        message: `Canceling overpriced orders (price=${accountMinUnitPrice}, diff=${quotePriceDiff})`\n      }),\n      actions: cancelMarketTokenOrder({\n        orders: accountOrders\n      })\n    };\n  }\n  if (hasOrders && quotePriceDiff <= 0) {\n    return {\n      action: 'cancel_stale_orders',\n      message: logMessage({\n        quoteToken,\n        baseToken,\n        message: `Canceling stale orders (price=${accountMinUnitPrice}, diff=${quotePriceDiff})`\n      }),\n      actions: cancelMarketTokenOrder({\n        orders: accountOrders\n      })\n    };\n  }\n  if (!hasOrders && effectiveQuoteUnit === 0) {\n    return {\n      action: 'wait',\n      message: logMessage({\n        quoteToken,\n        baseToken,\n        message: 'Nothing to sell'\n      })\n    };\n  }\n  if (!hasOrders) {\n    const nextUnitPrice = otherMinUnitPrice - 1;\n    if (nextUnitPrice < minUnitPrice) {\n      return {\n        action: 'wait',\n        message: logMessage({\n          quoteToken,\n          baseToken,\n          message: `Current market price ${nextUnitPrice} is too low, nothing to do`\n        })\n      };\n    }\n    const nextAskUnit = formatPriceUnit({\n      unitPrice: bn(nextUnitPrice).multiply(effectiveQuoteUnit).val(),\n      precision: baseToken.precision\n    });\n    const sellActions = announceMarketTokensSale({\n      accountName,\n      tokenContract: quoteToken.contract,\n      bidUnit: `${effectiveQuoteUnit.toFixed(quoteToken.precision)} ${quoteToken.tokenName}`,\n      askUnit: `${nextAskUnit} ${baseToken.tokenName}@${baseToken.contract}`\n    });\n    return {\n      action: 'send_sell_order',\n      message: logMessage({\n        quoteToken,\n        baseToken,\n        message: `Open sell order ${nextUnitPrice} price`\n      }),\n      actions: sellActions,\n      info: {\n        accountMinUnitPrice,\n        otherMinUnitPrice,\n        priceDiff,\n        minUnitPrice,\n        nextUnitPrice\n      }\n    };\n  }\n  return {\n    action: 'wait',\n    message: logMessage({\n      quoteToken,\n      baseToken,\n      message: 'No action needed'\n    })\n  };\n};\n\n// (async () => {\n//     const actions = await sendMarketSellOrderCalcNextAction({\n//         accountName: '5oyiw.wam',\n//         gameSettings: {\n//             orderSettings: {\n//                 tokens: [\n//                     'WAX+eosio.token',\n//                     'BGALPHA+beastreserve',\n//                 ],\n//                 quoteUnit: 2000,\n//                 minUnitPrice: 1459999,\n//                 targetBalance: 30000,\n//             },\n//         },\n//     });\n\n//     console.log(JSON.stringify(actions, null, 2));\n// })();\n\nmodule.exports = sendMarketSellOrderCalcNextAction;","map":{"version":3,"names":["_","require","bn","fetchDexWithOrders","formatPriceUnit","announceMarketTokensSale","cancelMarketTokensSale","ORDER_TYPES","logMessage","cancelMarketTokenOrder","orders","map","order","accountName","account","dexId","orderId","id","orderType","SELL","flatten","value","calcQuoteUnit","quoteUnit","currentBalance","targetBalance","diff","floor","sendMarketSellOrderCalcNextAction","gameSettings","orderSettings","tokens","minUnitPrice","fixMinPrice","Error","dexWithOrders","cache","quoteToken","baseToken","accountMinUnitPrice","otherMinUnitPrice","priceDiff","quotePriceDiff","accountOrders","sellOrders","effectiveQuoteUnit","accountAmount","hasOrders","length","console","log","action","message","actions","nextUnitPrice","nextAskUnit","unitPrice","multiply","val","precision","sellActions","tokenContract","contract","bidUnit","toFixed","tokenName","askUnit","info","module","exports"],"sources":["/Users/germangurov/projects/wax_bot/src/alcor/sendMarketSellOrderCalcNextAction.js"],"sourcesContent":["const _ = require('lodash');\nconst bn = require('big-number');\nconst fetchDexWithOrders = require('./api/fetchDexWithOrders');\nconst formatPriceUnit = require('./utils/formatPriceUnit');\nconst announceMarketTokensSale = require('./actions/announceMarketTokensSale');\nconst cancelMarketTokensSale = require('./actions/cancelMarketTokensSale');\nconst ORDER_TYPES = require('./consts/ORDER_TYPES');\nconst logMessage = require('./utils/logMessage');\n\nconst cancelMarketTokenOrder = ({\n    orders,\n}) => {\n    return _(orders)\n        .map(order => cancelMarketTokensSale({\n            accountName: order.account,\n            dexId: order.dexId,\n            orderId: order.id,\n            orderType: ORDER_TYPES.SELL,\n        }))\n        .flatten()\n        .value();\n};\n\nconst calcQuoteUnit = ({\n    quoteUnit,\n    currentBalance,\n    targetBalance = 0,\n}) => {\n    if ((currentBalance - quoteUnit) >= targetBalance) {\n        return quoteUnit;\n    }\n\n    const diff = currentBalance - targetBalance;\n\n    if (diff < 0) {\n        return 0;\n    }\n\n    return _.floor(diff);\n};\n\nconst sendMarketSellOrderCalcNextAction = async ({\n    accountName,\n    gameSettings: {\n        orderSettings: {\n            tokens,\n            quoteUnit,\n            minUnitPrice,\n            targetBalance,\n            fixMinPrice,\n        },\n        account = null\n    },\n}) => {\n    if (quoteUnit == null) {\n        throw new Error(`\"orderSettings\" should have \"quoteUnit\" declared`);\n    }\n    if (tokens == null) {\n        throw new Error(`\"orderSettings\" should have \"tokens\" declared`);\n    }\n    if (minUnitPrice == null) {\n        throw new Error(`\"orderSettings\" should have \"minUnitPrice\" declared`);\n    }\n    \n    const dexWithOrders = await fetchDexWithOrders({\n        accountName,\n        tokens,\n        cache: {\n            account,\n        },\n    });\n    const {\n        quoteToken,\n        baseToken,\n    } = dexWithOrders;\n    const {\n        accountMinUnitPrice,\n        otherMinUnitPrice,\n        priceDiff,\n        quotePriceDiff,\n        accountOrders,\n    } = dexWithOrders.sellOrders;\n    const effectiveQuoteUnit = calcQuoteUnit({\n        quoteUnit,\n        targetBalance,\n        currentBalance: quoteToken.accountAmount,\n    });\n    const hasOrders = accountOrders.length > 0;\n    console.log(\n        '>>>>',\n        hasOrders,\n        quoteUnit,\n        effectiveQuoteUnit,\n        quoteToken.accountAmount,\n        targetBalance,\n        priceDiff,\n        quotePriceDiff,\n    );\n\n    if (hasOrders && accountMinUnitPrice < minUnitPrice) {\n        return {\n            action: 'cancel_cheap_orders',\n            message: logMessage({\n                quoteToken,\n                baseToken,\n                message: `Canceling cheap orders (price=${accountMinUnitPrice}, min_price=${minUnitPrice})`,\n            }),\n            actions: cancelMarketTokenOrder({\n                orders: accountOrders,\n            }),\n        };\n    }\n\n    if (hasOrders && quotePriceDiff > 1) {\n        return {\n            action: 'cancel_overpriced_orders',\n            message: logMessage({\n                quoteToken,\n                baseToken,\n                message: `Canceling overpriced orders (price=${accountMinUnitPrice}, diff=${quotePriceDiff})`,\n            }),\n            actions: cancelMarketTokenOrder({\n                orders: accountOrders,\n            }),\n        };\n    }\n\n    if (hasOrders && quotePriceDiff <= 0) {\n        return {\n            action: 'cancel_stale_orders',\n            message: logMessage({\n                quoteToken,\n                baseToken,\n                message: `Canceling stale orders (price=${accountMinUnitPrice}, diff=${quotePriceDiff})`,\n            }),\n            actions: cancelMarketTokenOrder({\n                orders: accountOrders,\n            }),\n        };\n    }\n\n    if (!hasOrders && effectiveQuoteUnit === 0) {\n        return {\n            action: 'wait',\n            message: logMessage({\n                quoteToken,\n                baseToken,\n                message: 'Nothing to sell',\n            }),\n        };\n    }\n\n    if (!hasOrders) {\n        const nextUnitPrice = otherMinUnitPrice - 1;\n\n        if (nextUnitPrice < minUnitPrice) {\n            return {\n                action: 'wait',\n                message: logMessage({\n                    quoteToken,\n                    baseToken,\n                    message: `Current market price ${nextUnitPrice} is too low, nothing to do`,\n                }),\n            };\n        }\n\n        const nextAskUnit = formatPriceUnit({\n            unitPrice: bn(nextUnitPrice)\n                .multiply(effectiveQuoteUnit)\n                .val(),\n            precision: baseToken.precision,\n        });\n        const sellActions = announceMarketTokensSale({\n            accountName,\n            tokenContract: quoteToken.contract,\n            bidUnit: `${effectiveQuoteUnit.toFixed(quoteToken.precision)} ${quoteToken.tokenName}`,\n            askUnit: `${nextAskUnit} ${baseToken.tokenName}@${baseToken.contract}`,\n        });\n        \n        return {\n            action: 'send_sell_order',\n            message: logMessage({\n                quoteToken,\n                baseToken,\n                message: `Open sell order ${nextUnitPrice} price`,\n            }),\n            actions: sellActions,\n            info: {\n                accountMinUnitPrice,\n                otherMinUnitPrice,\n                priceDiff,\n                minUnitPrice,\n                nextUnitPrice,\n            },\n        };\n    }\n\n    return {\n        action: 'wait',\n        message: logMessage({\n            quoteToken,\n            baseToken,\n            message: 'No action needed',\n        }),\n    };\n};\n\n// (async () => {\n//     const actions = await sendMarketSellOrderCalcNextAction({\n//         accountName: '5oyiw.wam',\n//         gameSettings: {\n//             orderSettings: {\n//                 tokens: [\n//                     'WAX+eosio.token',\n//                     'BGALPHA+beastreserve',\n//                 ],\n//                 quoteUnit: 2000,\n//                 minUnitPrice: 1459999,\n//                 targetBalance: 30000,\n//             },\n//         },\n//     });\n\n//     console.log(JSON.stringify(actions, null, 2));\n// })();\n\n\nmodule.exports = sendMarketSellOrderCalcNextAction;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}