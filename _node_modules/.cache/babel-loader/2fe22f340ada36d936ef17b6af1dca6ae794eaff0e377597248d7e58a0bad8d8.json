{"ast":null,"code":"const _ = require('lodash');\nconst bn = require('big-number');\nconst fetchDexWithOrders = require('./api/fetchDexWithOrders');\nconst formatPriceUnit = require('./utils/formatPriceUnit');\nconst announceMarketTokensSale = require('./actions/announceMarketTokensSale');\nconst cancelMarketTokensSale = require('./actions/cancelMarketTokensSale');\nconst ORDER_TYPES = require('./consts/ORDER_TYPES');\nconst logMessage = require('./utils/logMessage');\nconst cancelMarketTokenOrder = ({\n  orders\n}) => {\n  return _(orders).map(order => cancelMarketTokensSale({\n    accountName: order.account,\n    dexId: order.dexId,\n    orderId: order.id,\n    orderType: ORDER_TYPES.BUY\n  })).flatten().value();\n};\nconst calcQuoteUnit = ({\n  quoteUnit,\n  targetBalance,\n  currentBalance\n}) => {\n  if (targetBalance == null) {\n    return quoteUnit;\n  }\n  if (currentBalance + quoteUnit <= targetBalance) {\n    return quoteUnit;\n  }\n  const diff = targetBalance - currentBalance;\n  if (diff < 0) {\n    return 0;\n  }\n  return diff;\n};\n\n// TODO: supporting startUnitPrice parameter - only for cases there are no active orders from others\n// TODO: checking balance before sending buy order, if balance is insufficient adjust it\nconst sendMarketBuyOrderCalcNextAction = async ({\n  accountName,\n  gameSettings: {\n    orderSettings: {\n      tokens,\n      quoteUnit,\n      maxUnitPrice,\n      targetBalance\n    },\n    account = null\n  }\n}) => {\n  if (quoteUnit == null) {\n    throw new Error(`\"orderSettings\" should have \"quoteUnit\" declared`);\n  }\n  if (tokens == null) {\n    throw new Error(`\"orderSettings\" should have \"tokens\" declared`);\n  }\n  if (maxUnitPrice == null) {\n    throw new Error(`\"orderSettings\" should have \"maxUnitPrice\" declared`);\n  }\n  const dexWithOrders = await fetchDexWithOrders({\n    accountName,\n    tokens,\n    cache: {\n      account\n    }\n  });\n  const {\n    quoteToken,\n    baseToken\n  } = dexWithOrders;\n  const {\n    accountMaxUnitPrice,\n    otherMaxUnitPrice,\n    priceDiff,\n    accountOrders\n  } = dexWithOrders.buyOrders;\n  const effectiveQuoteUnit = calcQuoteUnit({\n    quoteUnit,\n    targetBalance,\n    currentBalance: quoteToken.accountAmount\n  });\n  const hasOrders = accountOrders.length > 0;\n  if (hasOrders && otherMaxUnitPrice > maxUnitPrice) {\n    return {\n      action: 'cancel_expensive_orders',\n      message: logMessage({\n        quoteToken,\n        baseToken,\n        message: `Canceling expensive orders (price=${accountMaxUnitPrice}, max_price=${maxUnitPrice})`\n      }),\n      actions: cancelMarketTokenOrder({\n        orders: accountOrders\n      })\n    };\n  }\n  if (hasOrders && priceDiff <= 0) {\n    return {\n      action: 'cancel_stale_orders',\n      message: logMessage({\n        quoteToken,\n        baseToken,\n        message: `Canceling stale orders (price=${accountMaxUnitPrice})`\n      }),\n      actions: cancelMarketTokenOrder({\n        orders: accountOrders\n      })\n    };\n  }\n  if (!hasOrders && effectiveQuoteUnit === 0) {\n    return {\n      action: 'wait',\n      message: logMessage({\n        quoteToken,\n        baseToken,\n        message: 'Nothing to sell'\n      })\n    };\n  }\n  if (accountMaxUnitPrice == null || priceDiff <= 0) {\n    const nextUnitPrice = otherMaxUnitPrice + 1;\n    if (nextUnitPrice > maxUnitPrice) {\n      return {\n        action: 'wait',\n        message: logMessage({\n          quoteToken,\n          baseToken,\n          message: `Current market price ${nextUnitPrice} is too high, nothing to do`\n        })\n      };\n    }\n    const nextBidUnit = formatPriceUnit({\n      unitPrice: bn(nextUnitPrice).multiply(quoteUnit).val(),\n      precision: baseToken.precision\n    });\n    const buyActions = announceMarketTokensSale({\n      accountName,\n      tokenContract: baseToken.contract,\n      bidUnit: `${nextBidUnit} ${baseToken.tokenName}`,\n      askUnit: `${quoteUnit.toFixed(quoteToken.precision)} ${quoteToken.tokenName}@${quoteToken.contract}`\n    });\n    return {\n      action: 'send_buy_order',\n      message: logMessage({\n        quoteToken,\n        baseToken,\n        message: `Open buy order ${nextUnitPrice} price`\n      }),\n      actions: buyActions,\n      info: {\n        accountMaxUnitPrice,\n        otherMaxUnitPrice,\n        priceDiff,\n        maxUnitPrice,\n        nextUnitPrice\n      }\n    };\n  }\n  return {\n    action: 'wait',\n    message: logMessage({\n      quoteToken,\n      baseToken,\n      message: 'No action needed'\n    })\n  };\n};\n\n// (async () => {\n//     const actions = await sendMarketBuyOrderCalcNextAction({\n//         accountName: '5oyiw.wam',\n//         orderSettings: {\n//             tokens: [\n//                 'WAX+eosio.token',\n//                 'SNAKOIL+novarallytok',\n//             ],\n//             quoteUnit: 500000,\n//             maxUnitPrice: 1000,\n//             targetBalance: 45000000 * 9,\n\n//         },\n//     });\n\n//     console.log(JSON.stringify(actions, null, 2));\n// })();\n\nmodule.exports = sendMarketBuyOrderCalcNextAction;","map":{"version":3,"names":["_","require","bn","fetchDexWithOrders","formatPriceUnit","announceMarketTokensSale","cancelMarketTokensSale","ORDER_TYPES","logMessage","cancelMarketTokenOrder","orders","map","order","accountName","account","dexId","orderId","id","orderType","BUY","flatten","value","calcQuoteUnit","quoteUnit","targetBalance","currentBalance","diff","sendMarketBuyOrderCalcNextAction","gameSettings","orderSettings","tokens","maxUnitPrice","Error","dexWithOrders","cache","quoteToken","baseToken","accountMaxUnitPrice","otherMaxUnitPrice","priceDiff","accountOrders","buyOrders","effectiveQuoteUnit","accountAmount","hasOrders","length","action","message","actions","nextUnitPrice","nextBidUnit","unitPrice","multiply","val","precision","buyActions","tokenContract","contract","bidUnit","tokenName","askUnit","toFixed","info","module","exports"],"sources":["/Users/germangurov/projects/wax_bot/src/alcor/sendMarketBuyOrderCalcNextAction.js"],"sourcesContent":["const _ = require('lodash');\nconst bn = require('big-number');\nconst fetchDexWithOrders = require('./api/fetchDexWithOrders');\nconst formatPriceUnit = require('./utils/formatPriceUnit');\nconst announceMarketTokensSale = require('./actions/announceMarketTokensSale');\nconst cancelMarketTokensSale = require('./actions/cancelMarketTokensSale');\nconst ORDER_TYPES = require('./consts/ORDER_TYPES');\nconst logMessage = require('./utils/logMessage');\n\nconst cancelMarketTokenOrder = ({\n    orders,\n}) => {\n    return _(orders)\n        .map(order => cancelMarketTokensSale({\n            accountName: order.account,\n            dexId: order.dexId,\n            orderId: order.id,\n            orderType: ORDER_TYPES.BUY,\n        }))\n        .flatten()\n        .value();\n};\n\nconst calcQuoteUnit = ({\n    quoteUnit,\n    targetBalance,\n    currentBalance,\n}) => {\n    if (targetBalance == null) {\n        return quoteUnit;\n    }\n\n    if ((currentBalance + quoteUnit) <= targetBalance) {\n        return quoteUnit;\n    }\n\n    const diff = targetBalance - currentBalance;\n\n    if (diff < 0) {\n        return 0;\n    }\n\n    return diff;\n};\n\n// TODO: supporting startUnitPrice parameter - only for cases there are no active orders from others\n// TODO: checking balance before sending buy order, if balance is insufficient adjust it\nconst sendMarketBuyOrderCalcNextAction = async ({\n    accountName,\n    gameSettings: {\n        orderSettings: {\n            tokens,\n            quoteUnit,\n            maxUnitPrice,\n            targetBalance,\n        },\n        account = null,\n    },\n}) => {\n    if (quoteUnit == null) {\n        throw new Error(`\"orderSettings\" should have \"quoteUnit\" declared`);\n    }\n    if (tokens == null) {\n        throw new Error(`\"orderSettings\" should have \"tokens\" declared`);\n    }\n    if (maxUnitPrice == null) {\n        throw new Error(`\"orderSettings\" should have \"maxUnitPrice\" declared`);\n    }\n    \n    const dexWithOrders = await fetchDexWithOrders({\n        accountName,\n        tokens,\n        cache: {\n            account,\n        },\n    });\n    const {\n        quoteToken,\n        baseToken,\n    } = dexWithOrders;\n    const {\n        accountMaxUnitPrice,\n        otherMaxUnitPrice,\n        priceDiff,\n        accountOrders,\n    } = dexWithOrders.buyOrders;\n    const effectiveQuoteUnit = calcQuoteUnit({\n        quoteUnit,\n        targetBalance,\n        currentBalance: quoteToken.accountAmount,\n    });\n    const hasOrders = accountOrders.length > 0;\n\n    if (hasOrders && otherMaxUnitPrice > maxUnitPrice) {\n        return {\n            action: 'cancel_expensive_orders',\n            message: logMessage({\n                quoteToken,\n                baseToken,\n                message: `Canceling expensive orders (price=${accountMaxUnitPrice}, max_price=${maxUnitPrice})`,\n            }),\n            actions: cancelMarketTokenOrder({\n                orders: accountOrders,\n            }),\n        };\n    }\n\n    if (hasOrders && priceDiff <= 0) {\n        return {\n            action: 'cancel_stale_orders',\n            message: logMessage({\n                quoteToken,\n                baseToken,\n                message: `Canceling stale orders (price=${accountMaxUnitPrice})`,\n            }),\n            actions: cancelMarketTokenOrder({\n                orders: accountOrders,\n            }),\n        };\n    }\n\n    if (!hasOrders && effectiveQuoteUnit === 0) {\n        return {\n            action: 'wait',\n            message: logMessage({\n                quoteToken,\n                baseToken,\n                message: 'Nothing to sell',\n            }),\n        };\n    }\n\n    if (accountMaxUnitPrice == null || priceDiff <= 0) {\n        const nextUnitPrice = otherMaxUnitPrice + 1;\n\n        if (nextUnitPrice > maxUnitPrice) {\n            return {\n                action: 'wait',\n                message: logMessage({\n                    quoteToken,\n                    baseToken,\n                    message: `Current market price ${nextUnitPrice} is too high, nothing to do`,\n                }),\n            };\n        }\n\n        const nextBidUnit = formatPriceUnit({\n            unitPrice: bn(nextUnitPrice)\n                .multiply(quoteUnit)\n                .val(),\n            precision: baseToken.precision,\n        });\n        const buyActions = announceMarketTokensSale({\n            accountName,\n            tokenContract: baseToken.contract,\n            bidUnit: `${nextBidUnit} ${baseToken.tokenName}`,\n            askUnit: `${quoteUnit.toFixed(quoteToken.precision)} ${quoteToken.tokenName}@${quoteToken.contract}`,\n        });\n        \n        return {\n            action: 'send_buy_order',\n            message: logMessage({\n                quoteToken,\n                baseToken,\n                message: `Open buy order ${nextUnitPrice} price`,\n            }),\n            actions: buyActions,\n            info: {\n                accountMaxUnitPrice,\n                otherMaxUnitPrice,\n                priceDiff,\n                maxUnitPrice,\n                nextUnitPrice,\n            },\n        };\n    }\n\n    return {\n        action: 'wait',\n        message: logMessage({\n            quoteToken,\n            baseToken,\n            message: 'No action needed',\n        }),\n    };\n};\n\n// (async () => {\n//     const actions = await sendMarketBuyOrderCalcNextAction({\n//         accountName: '5oyiw.wam',\n//         orderSettings: {\n//             tokens: [\n//                 'WAX+eosio.token',\n//                 'SNAKOIL+novarallytok',\n//             ],\n//             quoteUnit: 500000,\n//             maxUnitPrice: 1000,\n//             targetBalance: 45000000 * 9,\n            \n//         },\n//     });\n\n//     console.log(JSON.stringify(actions, null, 2));\n// })();\n\n\nmodule.exports = sendMarketBuyOrderCalcNextAction;"],"mappings":"AAAA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAC3B,MAAMC,EAAE,GAAGD,OAAO,CAAC,YAAY,CAAC;AAChC,MAAME,kBAAkB,GAAGF,OAAO,CAAC,0BAA0B,CAAC;AAC9D,MAAMG,eAAe,GAAGH,OAAO,CAAC,yBAAyB,CAAC;AAC1D,MAAMI,wBAAwB,GAAGJ,OAAO,CAAC,oCAAoC,CAAC;AAC9E,MAAMK,sBAAsB,GAAGL,OAAO,CAAC,kCAAkC,CAAC;AAC1E,MAAMM,WAAW,GAAGN,OAAO,CAAC,sBAAsB,CAAC;AACnD,MAAMO,UAAU,GAAGP,OAAO,CAAC,oBAAoB,CAAC;AAEhD,MAAMQ,sBAAsB,GAAGA,CAAC;EAC5BC;AACJ,CAAC,KAAK;EACF,OAAOV,CAAC,CAACU,MAAM,CAAC,CACXC,GAAG,CAACC,KAAK,IAAIN,sBAAsB,CAAC;IACjCO,WAAW,EAAED,KAAK,CAACE,OAAO;IAC1BC,KAAK,EAAEH,KAAK,CAACG,KAAK;IAClBC,OAAO,EAAEJ,KAAK,CAACK,EAAE;IACjBC,SAAS,EAAEX,WAAW,CAACY;EAC3B,CAAC,CAAC,CAAC,CACFC,OAAO,CAAC,CAAC,CACTC,KAAK,CAAC,CAAC;AAChB,CAAC;AAED,MAAMC,aAAa,GAAGA,CAAC;EACnBC,SAAS;EACTC,aAAa;EACbC;AACJ,CAAC,KAAK;EACF,IAAID,aAAa,IAAI,IAAI,EAAE;IACvB,OAAOD,SAAS;EACpB;EAEA,IAAKE,cAAc,GAAGF,SAAS,IAAKC,aAAa,EAAE;IAC/C,OAAOD,SAAS;EACpB;EAEA,MAAMG,IAAI,GAAGF,aAAa,GAAGC,cAAc;EAE3C,IAAIC,IAAI,GAAG,CAAC,EAAE;IACV,OAAO,CAAC;EACZ;EAEA,OAAOA,IAAI;AACf,CAAC;;AAED;AACA;AACA,MAAMC,gCAAgC,GAAG,MAAAA,CAAO;EAC5Cd,WAAW;EACXe,YAAY,EAAE;IACVC,aAAa,EAAE;MACXC,MAAM;MACNP,SAAS;MACTQ,YAAY;MACZP;IACJ,CAAC;IACDV,OAAO,GAAG;EACd;AACJ,CAAC,KAAK;EACF,IAAIS,SAAS,IAAI,IAAI,EAAE;IACnB,MAAM,IAAIS,KAAK,CAAE,kDAAiD,CAAC;EACvE;EACA,IAAIF,MAAM,IAAI,IAAI,EAAE;IAChB,MAAM,IAAIE,KAAK,CAAE,+CAA8C,CAAC;EACpE;EACA,IAAID,YAAY,IAAI,IAAI,EAAE;IACtB,MAAM,IAAIC,KAAK,CAAE,qDAAoD,CAAC;EAC1E;EAEA,MAAMC,aAAa,GAAG,MAAM9B,kBAAkB,CAAC;IAC3CU,WAAW;IACXiB,MAAM;IACNI,KAAK,EAAE;MACHpB;IACJ;EACJ,CAAC,CAAC;EACF,MAAM;IACFqB,UAAU;IACVC;EACJ,CAAC,GAAGH,aAAa;EACjB,MAAM;IACFI,mBAAmB;IACnBC,iBAAiB;IACjBC,SAAS;IACTC;EACJ,CAAC,GAAGP,aAAa,CAACQ,SAAS;EAC3B,MAAMC,kBAAkB,GAAGpB,aAAa,CAAC;IACrCC,SAAS;IACTC,aAAa;IACbC,cAAc,EAAEU,UAAU,CAACQ;EAC/B,CAAC,CAAC;EACF,MAAMC,SAAS,GAAGJ,aAAa,CAACK,MAAM,GAAG,CAAC;EAE1C,IAAID,SAAS,IAAIN,iBAAiB,GAAGP,YAAY,EAAE;IAC/C,OAAO;MACHe,MAAM,EAAE,yBAAyB;MACjCC,OAAO,EAAEvC,UAAU,CAAC;QAChB2B,UAAU;QACVC,SAAS;QACTW,OAAO,EAAG,qCAAoCV,mBAAoB,eAAcN,YAAa;MACjG,CAAC,CAAC;MACFiB,OAAO,EAAEvC,sBAAsB,CAAC;QAC5BC,MAAM,EAAE8B;MACZ,CAAC;IACL,CAAC;EACL;EAEA,IAAII,SAAS,IAAIL,SAAS,IAAI,CAAC,EAAE;IAC7B,OAAO;MACHO,MAAM,EAAE,qBAAqB;MAC7BC,OAAO,EAAEvC,UAAU,CAAC;QAChB2B,UAAU;QACVC,SAAS;QACTW,OAAO,EAAG,iCAAgCV,mBAAoB;MAClE,CAAC,CAAC;MACFW,OAAO,EAAEvC,sBAAsB,CAAC;QAC5BC,MAAM,EAAE8B;MACZ,CAAC;IACL,CAAC;EACL;EAEA,IAAI,CAACI,SAAS,IAAIF,kBAAkB,KAAK,CAAC,EAAE;IACxC,OAAO;MACHI,MAAM,EAAE,MAAM;MACdC,OAAO,EAAEvC,UAAU,CAAC;QAChB2B,UAAU;QACVC,SAAS;QACTW,OAAO,EAAE;MACb,CAAC;IACL,CAAC;EACL;EAEA,IAAIV,mBAAmB,IAAI,IAAI,IAAIE,SAAS,IAAI,CAAC,EAAE;IAC/C,MAAMU,aAAa,GAAGX,iBAAiB,GAAG,CAAC;IAE3C,IAAIW,aAAa,GAAGlB,YAAY,EAAE;MAC9B,OAAO;QACHe,MAAM,EAAE,MAAM;QACdC,OAAO,EAAEvC,UAAU,CAAC;UAChB2B,UAAU;UACVC,SAAS;UACTW,OAAO,EAAG,wBAAuBE,aAAc;QACnD,CAAC;MACL,CAAC;IACL;IAEA,MAAMC,WAAW,GAAG9C,eAAe,CAAC;MAChC+C,SAAS,EAAEjD,EAAE,CAAC+C,aAAa,CAAC,CACvBG,QAAQ,CAAC7B,SAAS,CAAC,CACnB8B,GAAG,CAAC,CAAC;MACVC,SAAS,EAAElB,SAAS,CAACkB;IACzB,CAAC,CAAC;IACF,MAAMC,UAAU,GAAGlD,wBAAwB,CAAC;MACxCQ,WAAW;MACX2C,aAAa,EAAEpB,SAAS,CAACqB,QAAQ;MACjCC,OAAO,EAAG,GAAER,WAAY,IAAGd,SAAS,CAACuB,SAAU,EAAC;MAChDC,OAAO,EAAG,GAAErC,SAAS,CAACsC,OAAO,CAAC1B,UAAU,CAACmB,SAAS,CAAE,IAAGnB,UAAU,CAACwB,SAAU,IAAGxB,UAAU,CAACsB,QAAS;IACvG,CAAC,CAAC;IAEF,OAAO;MACHX,MAAM,EAAE,gBAAgB;MACxBC,OAAO,EAAEvC,UAAU,CAAC;QAChB2B,UAAU;QACVC,SAAS;QACTW,OAAO,EAAG,kBAAiBE,aAAc;MAC7C,CAAC,CAAC;MACFD,OAAO,EAAEO,UAAU;MACnBO,IAAI,EAAE;QACFzB,mBAAmB;QACnBC,iBAAiB;QACjBC,SAAS;QACTR,YAAY;QACZkB;MACJ;IACJ,CAAC;EACL;EAEA,OAAO;IACHH,MAAM,EAAE,MAAM;IACdC,OAAO,EAAEvC,UAAU,CAAC;MAChB2B,UAAU;MACVC,SAAS;MACTW,OAAO,EAAE;IACb,CAAC;EACL,CAAC;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAGAgB,MAAM,CAACC,OAAO,GAAGrC,gCAAgC"},"metadata":{},"sourceType":"module","externalDependencies":[]}