{"ast":null,"code":"const _ = require('lodash');\nconst CONTRACTS = require('./consts/CONTRACTS');\nconst buyShopItem = require('./actions/buyShopItem');\nconst fetchAccountBalance = require('../alcor/api/fetchAccountBalance');\nconst fetchShares = require('./api/fetchShares');\nconst SHARES_BUY_PRIORITIES = require('./consts/SHARES_BUY_PRIORITIES');\nconst buyShare = require('./actions/buyShare');\nconst BOOST_PRICE = 1000000;\nconst BOOST_BUY_SYMBOL = 'BOOST';\nconst CHARM_SYMBOL = 'CHARM';\nconst MAX_BOOSTS_PER_TRANSACTION = 15;\nconst MAX_SHARES_PER_TRANSACTION = 3;\nconst CHARM_MIN_BALANCE = 3000;\nconst buyItemsCalcNextAction = async ({\n  accountName\n}) => {\n  let actions = [];\n  const accountBalances = await fetchAccountBalance({\n    accountName\n  });\n\n  // buy boosts\n  const boostBalance = accountBalances.find(balance => balance.tokenName === BOOST_BUY_SYMBOL).amount;\n  const maxBuyBoostNum = _.floor(boostBalance / BOOST_PRICE);\n  const buyBoostNum = maxBuyBoostNum < MAX_BOOSTS_PER_TRANSACTION ? maxBuyBoostNum : MAX_BOOSTS_PER_TRANSACTION;\n  if (buyBoostNum > 0) {\n    actions = [...actions, ..._(_.range(buyBoostNum)).map(() => buyShopItem({\n      accountName,\n      itemId: 0,\n      price: `${BOOST_PRICE} ${BOOST_BUY_SYMBOL}`,\n      tokenAccount: CONTRACTS.TOKEN\n    })).flatten().value()];\n  }\n\n  // buy shares\n  let rounds = _(await fetchShares()).map(pool => _(pool.rounds).map(round => {\n    return {\n      manufacturerName: pool.manufacturer,\n      manufacturerPriority: _.findIndex(SHARES_BUY_PRIORITIES, prior => prior === pool.manufacturer),\n      ...round\n    };\n  }).value()).flatten().filter(round => round.amount > 0).orderBy(['id', 'manufacturerPriority']).value();\n  if (rounds.length > 0) {\n    const buyRound = rounds[0];\n    const price = Number(buyRound.price.split(' ')[0]);\n    const charmBalance = accountBalances.find(balance => balance.tokenName === CHARM_SYMBOL).amount;\n    const maxBuySharesNum = _.floor((charmBalance - CHARM_MIN_BALANCE) / price);\n    const limitBuySharesNum = buyRound.amount < MAX_SHARES_PER_TRANSACTION ? buyRound.amount : MAX_SHARES_PER_TRANSACTION;\n    const buySharesNum = maxBuySharesNum < limitBuySharesNum ? maxBuySharesNum : limitBuySharesNum;\n    if (buySharesNum > 0) {\n      actions = [...actions, ..._(_.range(buySharesNum)).map(() => buyShare({\n        accountName,\n        manufacturerName: buyRound.manufacturerName,\n        price: buyRound.price,\n        roundId: buyRound.id,\n        amount: 1\n      })).flatten().value()];\n    }\n  }\n  if (actions.length > 0) {\n    return {\n      action: 'buy_items',\n      actions: actions\n    };\n  }\n  return {\n    action: 'wait',\n    message: 'Nothing to buy in the internal novo shop'\n  };\n};\nmodule.exports = buyItemsCalcNextAction;","map":{"version":3,"names":["_","require","CONTRACTS","buyShopItem","fetchAccountBalance","fetchShares","SHARES_BUY_PRIORITIES","buyShare","BOOST_PRICE","BOOST_BUY_SYMBOL","CHARM_SYMBOL","MAX_BOOSTS_PER_TRANSACTION","MAX_SHARES_PER_TRANSACTION","CHARM_MIN_BALANCE","buyItemsCalcNextAction","accountName","actions","accountBalances","boostBalance","find","balance","tokenName","amount","maxBuyBoostNum","floor","buyBoostNum","range","map","itemId","price","tokenAccount","TOKEN","flatten","value","rounds","pool","round","manufacturerName","manufacturer","manufacturerPriority","findIndex","prior","filter","orderBy","length","buyRound","Number","split","charmBalance","maxBuySharesNum","limitBuySharesNum","buySharesNum","roundId","id","action","message","module","exports"],"sources":["/Users/germangurov/projects/wax_bot/src/novarallywax/buyItemsCalcNextAction.js"],"sourcesContent":["const _ = require('lodash');\nconst CONTRACTS = require('./consts/CONTRACTS');\nconst buyShopItem = require('./actions/buyShopItem');\nconst fetchAccountBalance = require('../alcor/api/fetchAccountBalance');\nconst fetchShares = require('./api/fetchShares');\nconst SHARES_BUY_PRIORITIES = require('./consts/SHARES_BUY_PRIORITIES');\nconst buyShare = require('./actions/buyShare');\n\nconst BOOST_PRICE = 1000000;\nconst BOOST_BUY_SYMBOL = 'BOOST';\nconst CHARM_SYMBOL = 'CHARM';\nconst MAX_BOOSTS_PER_TRANSACTION = 15;\nconst MAX_SHARES_PER_TRANSACTION = 3;\nconst CHARM_MIN_BALANCE = 3000;\n\nconst buyItemsCalcNextAction = async ({\n    accountName\n}) => {\n    let actions = [];\n    const accountBalances = await fetchAccountBalance({\n        accountName,\n    });\n\n    // buy boosts\n    const boostBalance = accountBalances.find(balance => balance.tokenName === BOOST_BUY_SYMBOL).amount;\n    const maxBuyBoostNum = _.floor(boostBalance / BOOST_PRICE);\n    const buyBoostNum = maxBuyBoostNum < MAX_BOOSTS_PER_TRANSACTION\n        ? maxBuyBoostNum\n        : MAX_BOOSTS_PER_TRANSACTION;\n    if (buyBoostNum > 0) {\n        actions = [\n            ...actions,\n            ..._(_.range(buyBoostNum))\n                .map(() => buyShopItem({\n                    accountName,\n                    itemId: 0,\n                    price: `${BOOST_PRICE} ${BOOST_BUY_SYMBOL}`,\n                    tokenAccount: CONTRACTS.TOKEN,\n                }))\n                .flatten()\n                .value(),\n        ];\n    }\n\n    // buy shares\n    let rounds = _(await fetchShares())\n        .map(pool => _(pool.rounds)\n            .map(round => {\n                return {\n                    manufacturerName: pool.manufacturer,\n                    manufacturerPriority: _.findIndex(SHARES_BUY_PRIORITIES, (prior) => prior === pool.manufacturer),\n                    ...round,\n                };\n            })\n            .value(),\n        )\n        .flatten()\n        .filter(round => round.amount > 0)\n        .orderBy(['id', 'manufacturerPriority'])\n        .value();\n    \n    if (rounds.length > 0) {\n        const buyRound = rounds[0];\n        const price = Number(buyRound.price.split(' ')[0]);\n        const charmBalance = accountBalances.find(balance => balance.tokenName === CHARM_SYMBOL).amount;\n        const maxBuySharesNum = _.floor((charmBalance - CHARM_MIN_BALANCE) / price);\n        const limitBuySharesNum = buyRound.amount < MAX_SHARES_PER_TRANSACTION\n            ? buyRound.amount\n            : MAX_SHARES_PER_TRANSACTION;\n        const buySharesNum = maxBuySharesNum < limitBuySharesNum\n            ? maxBuySharesNum\n            : limitBuySharesNum;\n        \n        if (buySharesNum > 0) {\n            actions = [\n                ...actions,\n                ..._(_.range(buySharesNum))\n                    .map(() => buyShare({\n                        accountName,\n                        manufacturerName: buyRound.manufacturerName,\n                        price: buyRound.price,\n                        roundId: buyRound.id,\n                        amount: 1,\n                    }))\n                    .flatten()\n                    .value()\n            ];\n        }\n    }\n    \n\n    if (actions.length > 0) {\n        return {\n            action: 'buy_items',\n            actions: actions,\n        };\n    }\n\n    return {\n        action: 'wait',\n        message: 'Nothing to buy in the internal novo shop',\n    };\n};\n\nmodule.exports = buyItemsCalcNextAction;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}