{"ast":null,"code":"const _ = require('lodash');\nconst fetchPlants = require('../plants/api/fetchPlants');\nconst fetchGrowthModifiers = require('../plants/api/fetchGrowthModifiers');\nconst fetchHarvestingSettings = require('../plants/api/fetchHarvestingSettings');\nconst fetchAccountPlantPower = require('../plants/api/fetchAccountPlantsPower');\nconst calcGrowthModifier = require('../plants/utils/calcGrowthModifier');\nconst calcGrowthProgress = require('../plants/utils/calcGrowthProgress');\nconst calcAccountHarvestPower = require('../plants/utils/calcAccountHarvestPower');\nconst fetchBattlepass = require('../battlepass/api/fetchBattlepass');\nconst fetchTokenPoolPrice = require('../../alcor/api/fetchTokenPoolPrice');\nconst TOKENS = require('../consts/TOKENS');\nconst fetchAccountBalance = require('../../alcor/api/fetchAccountBalance');\nconst harvestFruits = require('./actions/harvestFruits');\nconst WATER_BASE = 350;\nconst WATER_PER_POWER = 35;\nconst MAX_FRUIT_PRICE = 0.007;\nconst fetchHarvesting = async ({\n  accountName\n}) => {\n  const waterPrice = await fetchTokenPoolPrice(TOKENS.BGWATER);\n  const plants = await fetchPlants();\n  const growthModifiers = await fetchGrowthModifiers();\n  const harvestingSettings = await fetchHarvestingSettings();\n  const {\n    totalHarvestingPowerBonus\n  } = await fetchBattlepass({\n    accountName\n  });\n  const accountPlantPowers = await fetchAccountPlantPower({\n    accountName\n  });\n  const accountPlants = _(accountPlantPowers).map(plant => ({\n    ...plants.find(p => p.id === plant.id),\n    numFruits: plant.numFruits,\n    accountPower: plant.accountPower,\n    growthProgress: calcGrowthProgress({\n      curGrowthProgress: plant.curGrowthProgress,\n      growthProgressUpdatedAt: plant.growthProgressUpdatedAt,\n      harvestingSettings\n    })\n  })).map(plant => ({\n    ...plant,\n    accountPowerShare: _.round(plant.accountPower / plant.totalPower, 4),\n    growthModifier: calcGrowthModifier({\n      growthProgress: plant.growthProgress,\n      growthModifiers\n    }),\n    waterTotal: _.round(WATER_BASE + plant.accountPower * WATER_PER_POWER)\n  })).map(plant => ({\n    ...plant,\n    waterLeft: _.round((1 - plant.growthProgress) * plant.waterTotal, 2),\n    waterPerPower: _.round(plant.waterTotal / plant.accountPower, 2),\n    forecasts: _(plant.forecasts).map(forecast => ({\n      ...forecast,\n      envClaimPower: forecast.claimPower,\n      growthModifier: plant.growthModifier,\n      totalHarvestingPowerBonus,\n      curHarvestedFruits: _.round(calcAccountHarvestPower({\n        envClaimPower: forecast.claimPower,\n        accountPlantPower: plant.accountPower,\n        growthModifier: plant.growthModifier,\n        growthProgress: plant.growthProgress,\n        totalHarvestingPowerBonus\n      }) * plant.totalPool, 2),\n      maxHarvestedFruits: _.round(calcAccountHarvestPower({\n        envClaimPower: forecast.claimPower,\n        accountPlantPower: plant.accountPower,\n        growthModifier: calcGrowthModifier({\n          growthProgress: 1.0,\n          growthModifiers\n        }),\n        growthProgress: 1.0,\n        totalHarvestingPowerBonus\n      }) * plant.totalPool, 2)\n    })).map(forecast => ({\n      ...forecast,\n      pricePerFruitTotal: plant.waterTotal * waterPrice / forecast.maxHarvestedFruits\n    })).value()\n  })).map(plant => plant.forecasts.map(forecast => ({\n    plantId: plant.id,\n    forecastId: forecast.id,\n    ..._.omit(plant, ['id', 'forecasts']),\n    ..._.omit(forecast, ['id']),\n    pricePerFruitLeft: plant.waterLeft * waterPrice / forecast.maxHarvestedFruits\n  }))).flatten().sortBy(forecast => -new Date(forecast.startAt).getTime()).map(forecast => ({\n    plantId: forecast.plantId,\n    plantName: forecast.name,\n    totalPool: _.round(forecast.totalPool, 2),\n    waterPrice: _.floor(forecast.waterLeft, 0),\n    numHarvestedFruits: forecast.maxHarvestedFruits,\n    pricePerFruit: _.round(forecast.pricePerFruitLeft, 8),\n    isOngoing: forecast.hasStarted,\n    startAt: forecast.startAt,\n    endAt: forecast.endAt\n  })).filter(forecast => forecast.isOngoing).orderBy('pricePerFruit').sortBy(forecast => forecast.pricePerFruit).value();\n  return accountPlants;\n};\nconst harvestFruitsCalcNextAction = async ({\n  accountName\n}) => {\n  const accountBalances = await fetchAccountBalance({\n    accountName\n  });\n  const waterBalance = accountBalances.find(balance => balance.tokenName === 'BGWATER').amount;\n  const forecasts = await fetchHarvesting({\n    accountName\n  });\n  if (forecasts.length === 0) {\n    return {\n      action: 'wait',\n      message: 'No available forecasts'\n    };\n  }\n  const cheapestHarvestins = forecasts[0];\n  if (cheapestHarvestins.waterPrice > waterBalance) {\n    return {\n      action: 'wait',\n      message: 'Not enough water'\n    };\n  }\n  if (cheapestHarvestins.pricePerFruit > MAX_FRUIT_PRICE) {\n    return {\n      action: 'wait',\n      message: `Price ${cheapestHarvestins.plantName} is too hight ${_.round(cheapestHarvestins.pricePerFruit, 4)}`\n    };\n  }\n  const actions = harvestFruits({\n    accountName,\n    waterPrice: cheapestHarvestins.waterPrice,\n    plantId: cheapestHarvestins.plantId\n  });\n  return {\n    action: 'harvest_fruits',\n    message: `Harvesting ${cheapestHarvestins.plantName}, num fruits ${cheapestHarvestins.numHarvestedFruits}, price ${_.round(cheapestHarvestins.pricePerFruit, 4)}`,\n    actions\n  };\n};\nmodule.exports = harvestFruitsCalcNextAction;","map":{"version":3,"names":["_","require","fetchPlants","fetchGrowthModifiers","fetchHarvestingSettings","fetchAccountPlantPower","calcGrowthModifier","calcGrowthProgress","calcAccountHarvestPower","fetchBattlepass","fetchTokenPoolPrice","TOKENS","fetchAccountBalance","harvestFruits","WATER_BASE","WATER_PER_POWER","MAX_FRUIT_PRICE","fetchHarvesting","accountName","waterPrice","BGWATER","plants","growthModifiers","harvestingSettings","totalHarvestingPowerBonus","accountPlantPowers","accountPlants","map","plant","find","p","id","numFruits","accountPower","growthProgress","curGrowthProgress","growthProgressUpdatedAt","accountPowerShare","round","totalPower","growthModifier","waterTotal","waterLeft","waterPerPower","forecasts","forecast","envClaimPower","claimPower","curHarvestedFruits","accountPlantPower","totalPool","maxHarvestedFruits","pricePerFruitTotal","value","plantId","forecastId","omit","pricePerFruitLeft","flatten","sortBy","Date","startAt","getTime","plantName","name","floor","numHarvestedFruits","pricePerFruit","isOngoing","hasStarted","endAt","filter","orderBy","harvestFruitsCalcNextAction","accountBalances","waterBalance","balance","tokenName","amount","length","action","message","cheapestHarvestins","actions","module","exports"],"sources":["/Users/germangurov/projects/wax_bot/src/beastgarden/plants/harvestFruitsCalcNextAction.js"],"sourcesContent":["const _ = require('lodash');\nconst fetchPlants = require('../plants/api/fetchPlants');\nconst fetchGrowthModifiers = require('../plants/api/fetchGrowthModifiers');\nconst fetchHarvestingSettings = require('../plants/api/fetchHarvestingSettings');\nconst fetchAccountPlantPower = require('../plants/api/fetchAccountPlantsPower');\nconst calcGrowthModifier = require('../plants/utils/calcGrowthModifier');\nconst calcGrowthProgress = require('../plants/utils/calcGrowthProgress');\nconst calcAccountHarvestPower = require('../plants/utils/calcAccountHarvestPower');\nconst fetchBattlepass = require('../battlepass/api/fetchBattlepass');\nconst fetchTokenPoolPrice = require('../../alcor/api/fetchTokenPoolPrice');\nconst TOKENS = require('../consts/TOKENS');\nconst fetchAccountBalance = require('../../alcor/api/fetchAccountBalance');\nconst harvestFruits = require('./actions/harvestFruits');\n\nconst WATER_BASE = 350;\nconst WATER_PER_POWER = 35;\nconst MAX_FRUIT_PRICE = 0.007;\n\nconst fetchHarvesting = async ({accountName}) => {\n  const waterPrice = await fetchTokenPoolPrice(TOKENS.BGWATER);\n  const plants = await fetchPlants();\n  const growthModifiers = await fetchGrowthModifiers();\n  const harvestingSettings = await fetchHarvestingSettings();\n  const { totalHarvestingPowerBonus } = await fetchBattlepass({accountName});\n  const accountPlantPowers = await fetchAccountPlantPower({accountName})\n\n  const accountPlants = _(accountPlantPowers)\n    .map((plant) => ({\n      ...plants.find((p) => p.id === plant.id),\n      numFruits: plant.numFruits,\n      accountPower: plant.accountPower,\n      growthProgress: calcGrowthProgress({\n        curGrowthProgress: plant.curGrowthProgress,\n        growthProgressUpdatedAt: plant.growthProgressUpdatedAt,\n        harvestingSettings,\n      }),\n    }))\n    .map((plant) => ({\n      ...plant,\n      accountPowerShare: _.round(plant.accountPower / plant.totalPower, 4),\n      growthModifier: calcGrowthModifier({\n        growthProgress: plant.growthProgress,\n        growthModifiers,\n      }),\n      waterTotal: _.round(WATER_BASE + plant.accountPower * WATER_PER_POWER),\n    }))\n    .map((plant) => ({\n      ...plant,\n      waterLeft: _.round((1 - plant.growthProgress) * plant.waterTotal, 2),\n      waterPerPower: _.round(plant.waterTotal / plant.accountPower, 2),\n      forecasts: _(plant.forecasts)\n        .map((forecast) => ({\n          ...forecast,\n          envClaimPower: forecast.claimPower,\n          growthModifier: plant.growthModifier,\n          totalHarvestingPowerBonus,\n          curHarvestedFruits: _.round(\n            calcAccountHarvestPower({\n              envClaimPower: forecast.claimPower,\n              accountPlantPower: plant.accountPower,\n              growthModifier: plant.growthModifier,\n              growthProgress: plant.growthProgress,\n              totalHarvestingPowerBonus,\n            }) * plant.totalPool,\n            2,\n          ),\n          maxHarvestedFruits: _.round(\n            calcAccountHarvestPower({\n              envClaimPower: forecast.claimPower,\n              accountPlantPower: plant.accountPower,\n              growthModifier: calcGrowthModifier({\n                growthProgress: 1.0,\n                growthModifiers,\n              }),\n              growthProgress: 1.0,\n              totalHarvestingPowerBonus,\n            }) * plant.totalPool,\n            2,\n          ),\n        }))\n        .map((forecast) => ({\n          ...forecast,\n          pricePerFruitTotal:\n            (plant.waterTotal * waterPrice) / forecast.maxHarvestedFruits,\n        }))\n        .value(),\n    }))\n    .map((plant) =>\n      plant.forecasts.map((forecast) => ({\n        plantId: plant.id,\n        forecastId: forecast.id,\n        ..._.omit(plant, ['id', 'forecasts']),\n        ..._.omit(forecast, ['id']),\n        pricePerFruitLeft: (plant.waterLeft * waterPrice) / forecast.maxHarvestedFruits,\n      })),\n    )\n    .flatten()\n    .sortBy((forecast) => -new Date(forecast.startAt).getTime())\n    .map((forecast) => ({\n      plantId: forecast.plantId,\n      plantName: forecast.name,\n      totalPool: _.round(forecast.totalPool, 2),\n      waterPrice: _.floor(forecast.waterLeft, 0),\n      numHarvestedFruits: forecast.maxHarvestedFruits,\n      pricePerFruit: _.round(forecast.pricePerFruitLeft, 8),\n      isOngoing: forecast.hasStarted,\n      startAt: forecast.startAt,\n      endAt: forecast.endAt,\n    }))\n    .filter(forecast => forecast.isOngoing)\n    .orderBy('pricePerFruit')\n    .sortBy((forecast) => forecast.pricePerFruit)\n    .value();\n\n  return accountPlants;\n};\n\nconst harvestFruitsCalcNextAction = async ({\n    accountName,\n}) => {\n    const accountBalances = await fetchAccountBalance({\n        accountName,\n    });\n\n    const waterBalance = accountBalances.find(balance => balance.tokenName === 'BGWATER').amount;\n\n    const forecasts = await fetchHarvesting({\n        accountName,\n    });\n\n    if (forecasts.length === 0) {\n        return {\n            action: 'wait',\n            message: 'No available forecasts',\n        };\n    }\n\n    const cheapestHarvestins = forecasts[0];\n\n    if (cheapestHarvestins.waterPrice > waterBalance) {\n        return {\n            action: 'wait',\n            message: 'Not enough water',\n        };\n    }\n\n    if (cheapestHarvestins.pricePerFruit > MAX_FRUIT_PRICE) {\n        return {\n            action: 'wait',\n            message: `Price ${cheapestHarvestins.plantName} is too hight ${_.round(cheapestHarvestins.pricePerFruit, 4)}`,\n        };\n    }\n\n    const actions = harvestFruits({\n        accountName,\n        waterPrice: cheapestHarvestins.waterPrice,\n        plantId: cheapestHarvestins.plantId,\n    });\n\n    return {\n        action: 'harvest_fruits',\n        message: `Harvesting ${cheapestHarvestins.plantName}, num fruits ${cheapestHarvestins.numHarvestedFruits}, price ${_.round(cheapestHarvestins.pricePerFruit, 4)}`,\n        actions,\n    };\n};\n\nmodule.exports = harvestFruitsCalcNextAction;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}